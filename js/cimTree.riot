/*
 This tag renders a tree view of a given CIM diagram.

 Copyright 2017-2021 Daniele Pala (pala.daniele@gmail.com)

 This file is part of CIMDraw.

 CIMDraw is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 CIMDraw is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with CIMDraw. If not, see http://www.gnu.org/licenses/.
*/

<cimTree>
    <style>
     .tree {
         display: flex;
         flex-flow: column;
         max-height: 800px;
         min-width: 500px;
         resize: horizontal;
         padding-top: 10px;
         overflow: auto;
     }

     .tab-content {
         overflow: scroll;
     }

     .cim-tree-attribute-name {
         text-align: left;
         min-width: 200px;
     }

     .cim-tree-attribute-uom {
         width: 70px;
     }
     
     .cim-tree-btn-group {
         flex-grow: 1;
     }

     .cim-tree-dropdown-toggle {
         flex-grow: 1;
     }

     ul {
         list-style-type: none;
     }

     #tree-link-dialog {
         max-width: 18rem;
         align-self: center;
         min-width: 90%;
         min-height: min-content;
     }

     #tree-link-dialog > .card-body {
         text-align: center;
     }
     
     #tree-controls {
         padding-bottom: 10px;
         align-self: center;
         flex-shrink: 0;
         width: 370px;
     }

     #cim-search-form {
         align-self: center;
         max-width: 600px;
         padding-right: 20px;
         padding-left: 20px;
         padding-bottom: 20px;
     }

     .list-group-item > div {
         width: 100%;
     }

     .cim-tree-btn-group > .cimLinkBtn {
         flex-grow: 1;
     }

     .tree > .nav-tabs {
         flex-shrink: 0;
     }

     .cim-expand-object {
         border: transparent;
     }

     .cim-expand-object:focus {
         box-shadow: initial;
     }

     .cim-expand-object:hover {
         color: #6c757d;
         background-color: transparent;
     }

     li.attribute > .input-group {
         flex-wrap: nowrap
     }
    </style>

    <div class="app-tree" id="app-tree">
        <div class="tree">
            <div class="card bg-light mb-3 d-none" id="tree-link-dialog">
                <div class="card-body">
                    <h5 class="card-title">Choose the target element</h5>
                    <p class="card-text">Click on the selection box to select it.</p>
                    <button type="button" class="btn btn-outline-danger" id="tree-link-dialog-cancel">Cancel</button>
                </div>
            </div>
            <div class="row" id="tree-controls">
                <div class="col">
                    <div class="form-check form-switch">
                        <input type="checkbox" class="form-check-input" id="showAllObjects">
                        <label class="form-check-label" for="showAllObjects">Show all objects</label>
                    </div>
                </div>
                <div class="col">
                    <div class="form-check form-switch">
                        <input type="checkbox" class="form-check-input" id="sshInput">
                        <label class="form-check-label" for="sshInput">Power flow input</label>
                    </div>
                </div>
            </div>
            <div class="input-group" id="cim-search-form">
                <input type="text" class="form-control" placeholder="Search..." aria-label="Search" id="cim-search-key">
                <button class="btn btn-outline-secondary" id="cim-search-prev" type="button" title="Find previous">
                    <span class="fas fa-angle-up"></span>
                </button>
                <button class="btn btn-outline-secondary" id="cim-search-next" type="button" title="Find next">
                    <span class="fas fa-angle-down"></span>
                </button>
                <button class="btn btn-outline-secondary" type="button" id="cim-search-case" data-bs-toggle="button" aria-pressed="false" autocomplete="off">Match case</button>
                <span class="input-group-text d-none" id="cim-search-results"></span>                     
             </div>
            <!-- Nav tabs -->
            <ul class="nav nav-tabs" role="tablist" id="cim-tree-tabs">
                <li class="nav-item"><a class="nav-link active" data-bs-toggle="tab" href="#components" id="componentsTab" role="tab" aria-controls="components" aria-selected="true">Components</a></li>
                <li class="nav-item"><a class="nav-link" data-bs-toggle="tab" href="#containers" id="containersTab" role="tab" aria-controls="containers" aria-selected="false">Containers</a></li>
                <li class="nav-item"><a class="nav-link" data-bs-toggle="tab" href="#measurements" id="measurementsTab" role="tab" aria-controls="measurements" aria-selected="false">Measurements</a></li>
                <li class="nav-item"><a class="nav-link" data-bs-toggle="tab" href="#bases" id="basesTab" role="tab" aria-controls="bases" aria-selected="false">Bases</a></li>
                <li class="nav-item"><a class="nav-link" data-bs-toggle="tab" href="#curvesAndRegs" id="curvesAndRegsTab" role="tab" aria-controls="curves and regulations" aria-selected="false">Curves and Regulations</a></li>
                <li class="nav-item"><a class="nav-link" data-bs-toggle="tab" href="#limits" id="limitsTab" role="tab" aria-controls="operational limits" aria-selected="false">Operational Limits</a></li>
            </ul>
            <div class="tab-content" id="tab-content">
                <div role="tabpanel" class="tab-pane fade show active" id="components" aria-labelledby="componentsTab">
                    <ul class="list-group" id="CIMComponents"></ul>
                </div>
                <div role="tabpanel" class="tab-pane fade" id="containers" aria-labelledby="containersTab">
                    <ul class="list-group" id="CIMContainers"></ul>
                </div>
                <div role="tabpanel" class="tab-pane fade" id="measurements" aria-labelledby="measurementsTab">
                    <ul class="list-group" id="CIMMeasurements"></ul>
                </div>
                <div role="tabpanel" class="tab-pane fade" id="bases" aria-labelledby="basesTab">
                    <ul class="list-group" id="CIMBases"></ul>
                </div>
                <div role="tabpanel" class="tab-pane fade" id="curvesAndRegs" aria-labelledby="curvesAndRegsTab">
                    <ul class="list-group" id="CIMCurvesAndRegs"></ul>
                </div>
                <div role="tabpanel" class="tab-pane fade" id="limits" aria-labelledby="limitsTab">
                    <ul class="list-group" id="CIMLimits"></ul>
            </div>
            
        </div>
    </div>    
    <script>
    let self = null;
    let menu = d3.contextMenu([
        {
            title: "Delete",
            action: function(event, d) {
                self.props.model.deleteObject(d);
            }
        }
    ]);
    let searchResults = null;

    export default {
        onBeforeMount(props, state) {
            self = this;
            self.state.mode = "default";

            // listen to 'showDiagram' event from parent
            props.dispatcher.on("showDiagram", function(file, name, element) {
                if (decodeURI(name) !== self.state.diagramName) {
                    d3.drag().on("drag.end", null);
                    self.render(name);
                }
                if (typeof(element) !== "undefined") {
                    self.moveTo(element);
                } else {
                    // reset any element highlight
                    d3.select(".tree").selectAll(".btn-danger").classed("btn-danger", false).classed("btn-primary", true);
                }
            });
        },
     
        onMounted() {
            // Enable all tabs
            const triggerTabList = [].slice.call(document.querySelectorAll("#cim-tree-tabs a"));
            triggerTabList.forEach(function (triggerEl) {
                const tabTrigger = new bootstrap.Tab(triggerEl);

                triggerEl.addEventListener("click", function (event) {
                    event.preventDefault()
                    tabTrigger.show()
                });
            });


            // setup search input field
            document.getElementById("cim-search-key").addEventListener("keyup", function(event) {
                if (event.key === "Enter") {
                    // check if we are case-sensitive
                    let caseSensitive = document.getElementById("cim-search-case").classList.contains("active");
                    let searchKey = document.getElementById("cim-search-key").value;
                    if (searchKey === "") {
                        document.getElementById("cim-search-results").classList.add("d-none");
                        searchResults = null;
                    } else {
                        let total = [];
                        document.getElementById("app-tree").querySelectorAll("ul:not(.CIM-object-list)").forEach(function(el) {
                            let matches = null;
                            if (caseSensitive === true) {
                                matches = Array.prototype.filter.call(el.querySelectorAll("li.CIM-object>button.cim-object-btn"), function(btn) {
                                    let target = btn.textContent;
                                    return (target.indexOf(searchKey) >= 0);
                                });
                            } else {
                                matches = Array.prototype.filter.call(el.querySelectorAll("li.CIM-object>button.cim-object-btn"), function(btn) {
                                    let searchString = searchKey.toLocaleLowerCase();
                                    let target = btn.textContent.toLocaleLowerCase();
                                    return (target.indexOf(searchString) >= 0);
                                });
                            }
                            total = total.concat(matches);
                        });
                        total = [...new Set(total)];
                        document.getElementById("cim-search-results").classList.remove("d-none");
                        if (total.length > 0) {
                            document.querySelector("#cim-search-results").textContent = "Result 1 of " + total.length;
                            searchResults = {elements: d3.selectAll(total).data(), actualResult: 0};
                            self.moveTo(self.props.model.ID(searchResults.elements[searchResults.actualResult]));
                        } else {
                            document.querySelector("#cim-search-results").textContent = "Text not found"; 
                        }
                    }
                }
            });

            // setup search buttons
            document.getElementById("cim-search-next").addEventListener("click", function() {
                if (searchResults !== null) {
                    if (searchResults.actualResult < (searchResults.elements.length - 1)) {
                        searchResults.actualResult = searchResults.actualResult + 1;
                        let result = searchResults.actualResult + 1;
                        document.querySelector("#cim-search-results").textContent = "Result " + result  + " of " + searchResults.elements.length;
                        self.moveTo(self.props.model.ID(searchResults.elements[searchResults.actualResult]));
                    } 
                }
            });
            document.getElementById("cim-search-prev").addEventListener("click", function() {
                if (searchResults !== null) {
                    if (searchResults.actualResult > 0) {
                        searchResults.actualResult = searchResults.actualResult - 1;
                        let result = searchResults.actualResult + 1;
                        document.querySelector("#cim-search-results").textContent = "Result " + result  + " of " + searchResults.elements.length;
                        self.moveTo(self.props.model.ID(searchResults.elements[searchResults.actualResult]));
                    } 
                }
            });
            document.getElementById("showAllObjects").addEventListener("change", function() {
                self.createTree(this.checked);
            });
            document.getElementById("sshInput").addEventListener("change", function() {
                self.resetAttrs();
            });
            // setup tabs: reset path upon clicking on another tab
            document.querySelectorAll("a[data-bs-toggle=\"tab\"]").forEach(tab => tab.addEventListener("click", function(e) {
                self.goToBasePath();
            }));

            // listen to 'addToActiveDiagram' event from model
            self.props.model.on("addToActiveDiagram", function(object) {
                self.addNewObject(object);
            });
            // listen to 'deleteObject' event from model
            self.props.model.on("deleteObject", function(objectUUID, objectType) {
                self.deleteObject(objectUUID);
            });
            // listen to 'deleteFromDiagram' event from model
            self.props.model.on("deleteFromDiagram", function(objectUUID) {
                if (document.getElementById("showAllObjects").checked === false) {
                    self.deleteObject(objectUUID);
                }
            });
            // listen to 'setAttribute' event from model
            self.props.model.on("setAttribute", function(object, attrName, value) {
                if (attrName === "cim:IdentifiedObject.name") {
                    let type = object.localName;
                    let target = d3.select("div.tree")
                                .selectAll("ul#" + self.props.model.ID(object));
                    if (target.empty() === false) {
                        let btn = d3.select(target.node().parentNode).select("button");
                        btn.html(value);
                    }
                    document.querySelectorAll("[cim-target=\"" + self.props.model.ID(object) + "\"]").innerHTML = value;
                }
            });
            // listen to 'addLink' event from model
            self.props.model.on("addLink", function(source, linkName, target) {
                let sourceUUID = self.props.model.ID(source);
                let sourceNode = d3.select(".tree").select("#" + sourceUUID);
                let removeBtn = sourceNode.selectAll("#cimRemoveBtn").filter(function(d) {
                    return (d.attributes[0].value === "#" + linkName.split(":")[1]);
                });
                let linkBtn = sourceNode.selectAll(".cimLinkBtn").filter(function(d) {
                    return (d.attributes[0].value === "#" + linkName.split(":")[1]);
                });

                linkBtn.html(function() {
                    return self.props.model.getAttribute(target, "cim:IdentifiedObject.name").textContent;
                }).attr("cim-target", function() {
                    return self.props.model.ID(target);
                }).attr("disabled", null);
                sourceNode.selectAll("#cimTarget").attr("id", null);
                removeBtn.attr("disabled", null);
                // in bus-branch mode, we need to update base voltage
                // of topological node if the associated busbar is
                // updated.
                if (self.props.model.getMode() === "BUS_BRANCH") {
                    if (source.nodeName === "cim:BusbarSection" && linkName === "cim:ConductingEquipment.BaseVoltage") {
                        self.props.model.setLink(self.props.model.getNode(source), "cim:TopologicalNode.BaseVoltage", target);
                    }
                }
            });
            // listen to 'removeLink' event from model
            self.props.model.on("removeLink", function(source, linkName, target) {
                let sourceUUID = self.props.model.ID(source);
                let sourceNode = d3.select(".tree").select("#" + sourceUUID);
                let removeBtn = sourceNode.selectAll("#cimRemoveBtn").filter(function(d) {
                    return (d.attributes[0].value === "#" + linkName.split(":")[1]);
                });
                let linkBtn = sourceNode.selectAll(".cimLinkBtn").filter(function(d) {
                    return (d.attributes[0].value === "#" + linkName.split(":")[1]);
                });
                removeBtn.attr("disabled", "disabled");
                linkBtn.html("none")
                        .attr("cim-target", "none")
                        .attr("disabled", "disabled");
            });
            // listen to 'createdDiagram' event from model
            self.props.model.on("createdDiagram", function() {
                self.state.diagramName = decodeURI(self.props.model.activeDiagramName);
                // the toggling of this checkbox actually renders the tree
                document.getElementById("showAllObjects").checked = false;
                document.getElementById("showAllObjects").dispatchEvent(new MouseEvent("click"));
            });
            // listen to 'setMode' event from model
            // this is used in order to hide operational stuff
            // when working in bus-branch mode.
            self.props.model.on("setMode", function(mode) {
                if (self.state.mode === "BUS_BRANCH") {
                    document.getElementById("measurementsTab").style.display = null;;
                }
            });
        },

        goToBasePath() {
            let hashComponents = window.location.hash.substring(1).split("/");
            if (hashComponents.length > 3) {
                let basePath = hashComponents[0] + "/" + hashComponents[1] + "/" + hashComponents[2];
                route.router.push(basePath);
            }
        },
     
        addNewObject(object) {
            const tabs = d3.select("div.tree > div.tab-content > div.tab-pane");
            const cimNetwork = d3.select("div.tree > div.tab-content > div.tab-pane > ul#CIMComponents");
            const cimContainers = d3.select("div.tree > div.tab-content > div.tab-pane > ul#CIMContainers");
            const cimMeasurements = d3.select("div.tree > div.tab-content > div.tab-pane > ul#CIMMeasurements");
            const cimBases = d3.select("div.tree > div.tab-content > div.tab-pane > ul#CIMBases");
            const cimCurvesAndRegs = d3.select("div.tree > div.tab-content > div.tab-pane > ul#CIMCurvesAndRegs");
            const cimLimits = d3.select("div.tree > div.tab-content > div.tab-pane > ul#CIMLimits");
            switch (object.nodeName) {
                case "cim:ACLineSegment": {
                    self.elements(cimNetwork, "ACLineSegment", "AC Line Segments", [object]);
                    break;
                }
                case "cim:Breaker": {
                    self.elements(cimNetwork, "Breaker", "Breakers", [object]);
                    break;
                }
                case "cim:Disconnector": {
                    self.elements(cimNetwork, "Disconnector", "Disconnectors", [object]);
                    break;
                }
                case "cim:LoadBreakSwitch": {
                    self.elements(cimNetwork, "LoadBreakSwitch", "Load Break Switches", [object]);
                    break;
                }
                case "cim:Junction": {
                    self.elements(cimNetwork, "Junction", "Junctions", [object]);
                    break;
                }
                case "cim:EnergySource": {
                    const equivalents = self.createTopContainer(cimNetwork, "Equivalent", "Equivalents", [object]);
                    self.elements(equivalents, "EnergySource", "Energy Sources", [object]);
                    break;
                }
                case "cim:SynchronousMachine": {
                    const rotMac = self.createTopContainer(cimNetwork, "RotatingMachine", "RotatingMachines", [object]);
                    self.elements(rotMac, "SynchronousMachine", "Synchronous Machines", [object]);
                    break;
                }
                case "cim:AsynchronousMachine": {
                    const rotMac = self.createTopContainer(cimNetwork, "RotatingMachine", "RotatingMachines", [object]);
                    self.elements(rotMac, "AsynchronousMachine", "Asynchronous Machines", [object]);
                    break;
                }
                case "cim:EnergyConsumer": {
                    const loads = self.createTopContainer(cimNetwork, "Load", "Loads", [object]);
                    self.elements(loads, "EnergyConsumer", "Energy Consumers", [object]);
                    break;
                }
                case "cim:ConformLoad": {
                    const loads = self.createTopContainer(cimNetwork, "Load", "Loads", [object]);
                    self.elements(loads, "ConformLoad", "Conform Loads", [object]);
                    break;
                }
                case "cim:NonConformLoad": {
                    const loads = self.createTopContainer(cimNetwork, "Load", "Loads", [object]);
                    self.elements(loads, "NonConformLoad", "Non Conform Loads", [object]);
                    break;
                }
                case "cim:LinearShuntCompensator": {
                    const allComps = self.createTopContainer(cimNetwork, "Compensator", "Compensators", [object]);
                    self.elements(allComps, "LinearShuntCompensator", "Linear", [object]);
                    break;
                }
                case "cim:NonlinearShuntCompensator": {
                    const allComps = self.createTopContainer(cimNetwork, "Compensator", "Compensators", [object]);
                    self.nlCompensators(allComps, [object]);
                    break;
                }
                case "cim:NonlinearShuntCompensatorPoint": {
                    const nlc = self.props.model.getTargets([object], "NonlinearShuntCompensatorPoint.NonlinearShuntCompensator");
                    const nlcUUID = self.props.model.ID(nlc[0]);
                    const nlcG = cimNetwork.selectAll("ul#" + nlcUUID);
                    self.nlCompensatorPoints(nlcG, [object]);
                    break;
                }
                case "cim:PowerTransformer": {
                    self.powerTransformers(cimNetwork, [object]);
                    break;
                }
                case "cim:RatioTapChanger": {
                    const tcEnd = self.props.model.getTargets([object], "RatioTapChanger.TransformerEnd");
                    const endUUID = self.props.model.ID(tcEnd[0]);
                    const endG = cimNetwork.selectAll("ul#" + endUUID);
                    self.tapChangers(endG, [object]);
                    break;
                }
                case "cim:BusbarSection": {
                    self.elements(cimNetwork, "BusbarSection", "Nodes", [object]);
                    break;
                }
                case "cim:BaseVoltage": {
                    const bvEnter = self.elements(cimBases, "BaseVoltage", "Base Voltages", [object]);
                    self.createDeleteMenu(bvEnter);
                    break;
                }
                case "cim:GeographicalRegion": {
                    self.geoRegions(cimContainers, [object]);
                    break;
                }
                case "cim:SubGeographicalRegion": {
                    const region = self.props.model.getTargets([object], "SubGeographicalRegion.Region");
                    const regionUUID = self.props.model.ID(region[0]);
                    const regionG = cimContainers.selectAll("ul#" + regionUUID);
                    self.subGeoRegions(regionG, [object]);
                    break;   
                }       
                case "cim:Substation": {
                    self.substations(cimContainers, [object]);
                    break;
                }
                case "cim:VoltageLevel": {
                    const vlSub = self.props.model.getTargets([object], "VoltageLevel.Substation");
                    const subUUID = self.props.model.ID(vlSub[0]);
                    const subG = cimContainers.selectAll("ul#" + subUUID);
                    self.voltageLevels(subG, [object]);
                    break;
                }
                case "cim:Bay": {
                    const bayVl = self.props.model.getTargets([object], "Bay.VoltageLevel");
                    const vlUUID = self.props.model.ID(bayVl[0]);
                    const vlG = cimContainers.selectAll("ul#" + vlUUID);
                    self.bays(vlG, [object]);
                    break;
                }
                case "cim:Line": {
                    const lineEnter = self.elements(cimContainers, "Line", "Lines", [object]);
                    self.createDeleteMenu(lineEnter);
                    break;
                }
                case "cim:GeneratingUnit": {
                    const genUnits = self.createTopContainer(cimContainers, "GeneralGeneratingUnit", "Generating Units", [object]);
                    self.elements(genUnits, "GeneratingUnit", "General Units", [object]);
                    break;
                }
                case "cim:ThermalGeneratingUnit": {
                    const genUnits = self.createTopContainer(cimContainers, "GeneralGeneratingUnit", "Generating Units", [object]);
                    self.elements(genUnits, "ThermalGeneratingUnit", "Thermal Units", [object]);
                    break;
                }
                case "cim:Analog": {
                    const analogEnter = self.elements(cimMeasurements, "Analog", "Analogs", [object]);
                    self.createDeleteMenu(analogEnter);
                    break;
                }
                case "cim:Discrete": {
                    const discEnter = self.elements(cimMeasurements, "Discrete", "Discretes", [object]);
                    self.createDeleteMenu(discEnter);
                    break;
                }
                case "cim:LoadResponseCharacteristic": {
                    const lrEnter = self.elements(cimCurvesAndRegs, "LoadResponseCharacteristic", "Load Response Characteristics", [object]);
                    self.createDeleteMenu(lrEnter);
                    break;
                }
                case "cim:TapChangerControl": {
                    const tccEnter = self.elements(cimCurvesAndRegs, "TapChangerControl", "Tap Changer Controls", [object]);
                    self.createDeleteMenu(tccEnter);
                    break;
                }
                case "cim:RegulatingControl": {
                    const rcEnter = self.elements(cimCurvesAndRegs, "RegulatingControl", "Regulating Controls", [object]);
                    self.createDeleteMenu(rcEnter);
                    break;
                }
                case "cim:OperationalLimitType": {
                    const limTypesEnter = self.elements(cimLimits, "OperationalLimitType", "Operational Limit Types", [object]);
                    self.createDeleteMenu(limTypesEnter);
                    break;
                }
                case "cim:OperationalLimitSet": {
                    let eq = self.props.model.getTargets([object], "OperationalLimitSet.Equipment");
                    if (eq.length === 0) {
                        const term = self.props.model.getTargets([object], "OperationalLimitSet.Terminal");
                        eq = self.props.model.getTargets(term, "Terminal.ConductingEquipment");
                    }
                    const eqUUID = self.props.model.ID(eq[0]);
                    const eqG = tabs.selectAll("ul#" + eqUUID);
                    self.limitSets(eqG, [object]);
                    break;
                }
                case "cim:VoltageLimit":
                case "cim:CurrentLimit":
                case "cim:ActivePowerLimit":
                case "cim:ApparentPowerLimit": {
                    const opSet = self.props.model.getTargets([object], "OperationalLimit.OperationalLimitSet");
                    const setUUID = self.props.model.ID(opSet[0]);
                    const setG = tabs.selectAll("ul#" + setUUID);
                    self.limits(setG, [object]);
                    break;
                }
                default:
            }       
        },

        createTree(showAllObjects) {
            let treeRender = createTreeGenerator(showAllObjects);
            function periodic() {
                let ret = treeRender.next().value;
                if (typeof(ret) !== "undefined") {
                    document.getElementById("loadingDiagramMsg").innerHTML = "<br>" + ret;
                    setTimeout(periodic, 1);
                } else {
                    self.props.dispatcher.trigger("loaded");
                }
            };
            periodic();

            function* createTreeGenerator(showAllObjects) {
                // clear all
                d3.select("#app-tree").selectAll("#CIMComponents > li").remove();
                d3.select("#app-tree").selectAll("#CIMContainers > li").remove();
                d3.select("#app-tree").selectAll("#CIMMeasurements > li").remove();
                d3.select("#app-tree").selectAll("#CIMBases > li").remove();
                d3.select("#app-tree").selectAll("#CIMCurvesAndRegs > li").remove();
                d3.select("#app-tree").selectAll("#CIMLimits > li").remove();
                let cimNetwork = d3.select("div.tree > div.tab-content > div.tab-pane > ul#CIMComponents");
                let cimContainers = d3.select("div.tree > div.tab-content > div.tab-pane > ul#CIMContainers");
                let cimMeasurements = d3.select("div.tree > div.tab-content > div.tab-pane > ul#CIMMeasurements");
                let cimBases = d3.select("div.tree > div.tab-content > div.tab-pane > ul#CIMBases");
                let cimCurvesAndRegs = d3.select("div.tree > div.tab-content > div.tab-pane > ul#CIMCurvesAndRegs");
                let cimLimits = d3.select("div.tree > div.tab-content > div.tab-pane > ul#CIMLimits");
                let contNames = ["cim:Substation", "cim:Line"];
                let measNames = ["cim:Analog", "cim:Discrete"];
                let genNames = ["cim:GeneratingUnit", "cim:ThermalGeneratingUnit"];
                let allContainers = null;
                let allMeasurements = null;
                let allGeneratingUnits = null;
                let allSubGeoRegions = null;
                let allGeoRegions = null;
                let allLoadResponses = null;
                // setup the right function to get objects
                let getObjects = self.props.model.getObjects;
                let getConnectors = self.props.model.getObjects;
                if (showAllObjects === false) {
                    getObjects = self.props.model.getGraphicObjects;
                    getConnectors = self.props.model.getConnectors;
                }
                // in bus-branch mode, we artificially add busbar sections
                // (1-1 correspondence with topological nodes)
                if (self.props.model.getMode() === "BUS_BRANCH") {
                    let objects = self.props.model.getObjects(["cim:BusbarSection", "cim:TopologicalNode"]); 
                    if (objects["cim:BusbarSection"].length === 0) {
                        objects["cim:TopologicalNode"].forEach(function(topo) {
                            let newObj = self.props.model.createObject("cim:BusbarSection", {node: topo});
                            let name = self.props.model.getAttribute(topo, "cim:IdentifiedObject.name");
                            if (typeof(name) !== "undefined") {
                                self.props.model.setAttribute(newObj, "cim:IdentifiedObject.name", name.innerHTML);
                            }
                        });
                    }
                }

                // get all equipments
                let eqs = getObjects([
                    "cim:BusbarSection",
                    "cim:PowerTransformer",
                    "cim:ACLineSegment",
                    "cim:Breaker",
                    "cim:Disconnector",
                    "cim:LoadBreakSwitch",
                    "cim:Junction",
                    "cim:EnergySource",
                    "cim:EquivalentInjection",
                    "cim:SynchronousMachine",
                    "cim:AsynchronousMachine",
                    "cim:EnergyConsumer",
                    "cim:ConformLoad",
                    "cim:NonConformLoad",
                    "cim:LinearShuntCompensator",
                    "cim:NonlinearShuntCompensator"
                ]);
                yield "TREE: extracted equipments";
                // get additional objects
                allSubGeoRegions = getObjects(["cim:SubGeographicalRegion"])["cim:SubGeographicalRegion"];
                allGeoRegions = getObjects(["cim:GeographicalRegion"])["cim:GeographicalRegion"];
                if (showAllObjects === false) {
                    allContainers = self.props.model.getLinkedObjects(
                        contNames,
                        ["EquipmentContainer.Equipments",
                        "Substation.VoltageLevels/EquipmentContainer.Equipments",
                        "Substation.VoltageLevels/VoltageLevel.Bays/EquipmentContainer.Equipments"]);
                    allMeasurements = self.props.model.getLinkedObjects(
                        measNames,
                        ["Measurement.PowerSystemResource"]);
                    allGeneratingUnits = self.props.model.getLinkedObjects(
                        genNames,
                        ["GeneratingUnit.RotatingMachine"]);
                    allSubGeoRegions = allSubGeoRegions.concat(
                        self.props.model.getTargets(
                            allContainers["cim:Substation"],
                            "Substation.Region"));
                    allGeoRegions = allGeoRegions.concat(
                        self.props.model.getTargets(
                            allSubGeoRegions,
                            "SubGeographicalRegion.Region"));
                    allSubGeoRegions = [...new Set(allSubGeoRegions)];
                    allGeoRegions = [...new Set(allGeoRegions)];
                    allLoadResponses = self.props.model.getLinkedObjects(
                        ["cim:LoadResponseCharacteristic"],
                        ["LoadResponseCharacteristic.EnergyConsumer"]);
                } else {
                    allContainers = getObjects(contNames);
                    allMeasurements = getObjects(measNames);
                    allGeneratingUnits = getObjects(genNames);
                    allLoadResponses = getObjects(["cim:LoadResponseCharacteristic"]);
                }
                let noDiagObjs = self.props.model.getObjects(
                    ["cim:BaseVoltage",
                    "cim:TapChangerControl",
                    "cim:RegulatingControl",
                    "cim:OperationalLimitType"])
                let allBusbarSections = getConnectors(["cim:BusbarSection"])["cim:BusbarSection"];
                let allInjections = eqs["cim:EnergySource"].concat(eqs["cim:EquivalentInjection"]);
                let allRotatingMachines = eqs["cim:SynchronousMachine"].concat(eqs["cim:AsynchronousMachine"]);
                let allEnergyConsumers = eqs["cim:EnergyConsumer"].concat(eqs["cim:ConformLoad"]).concat(eqs["cim:NonConformLoad"]);
                let allCompensators = eqs["cim:LinearShuntCompensator"].concat(eqs["cim:nonlinearShuntCompensator"]);
                // ====================================================================
                // ========================= "Measurements" ===========================
                // ====================================================================
                let analogEnter = self.elements(cimMeasurements, "Analog", "Analogs", allMeasurements["cim:Analog"]);
                self.createDeleteMenu(analogEnter);
                let discEnter = self.elements(cimMeasurements, "Discrete", "Discretes", allMeasurements["cim:Discrete"]);
                self.createDeleteMenu(discEnter);
                // ====================================================================
                // ============================= "Bases" ==============================
                // ====================================================================
                let bvEnter = self.elements(cimBases, "BaseVoltage", "Base Voltages", noDiagObjs["cim:BaseVoltage"]);
                self.createDeleteMenu(bvEnter);
                // ====================================================================
                // =========================== "Components" ===========================
                // ====================================================================
                self.elements(cimNetwork, "ACLineSegment", "AC Line Segments", eqs["cim:ACLineSegment"]);
                self.elements(cimNetwork, "Breaker", "Breakers", eqs["cim:Breaker"]);
                self.elements(cimNetwork, "Disconnector", "Disconnectors", eqs["cim:Disconnector"]);
                self.elements(cimNetwork, "LoadBreakSwitch", "Load Break Switches", eqs["cim:LoadBreakSwitch"]);
                self.elements(cimNetwork, "Junction", "Junctions", eqs["cim:Junction"]);
                // Generic and external injections
                let allEquivalents = self.createTopContainer(cimNetwork, "Equivalent", "Equivalents", allInjections);
                self.elements(allEquivalents, "EnergySource", "Energy Sources", eqs["cim:EnergySource"]);
                self.elements(allEquivalents, "EquivalentInjection", "Equivalent Injections", eqs["cim:EquivalentInjection"]);
                // Rotating machines
                let allRotMac = self.createTopContainer(cimNetwork, "RotatingMachine", "Rotating Machines", allRotatingMachines);
                self.elements(allRotMac, "SynchronousMachine", "Synchronous Machines", eqs["cim:SynchronousMachine"]);
                self.elements(allRotMac, "AsynchronousMachine", "Asynchronous Machines", eqs["cim:AsynchronousMachine"]);
                // Loads
                let allLoads = self.createTopContainer(cimNetwork, "Load", "Loads", allEnergyConsumers);
                self.elements(allLoads, "EnergyConsumer", "Energy Consumers", eqs["cim:EnergyConsumer"]);
                self.elements(allLoads, "ConformLoad", "Conform Loads", eqs["cim:ConformLoad"]);
                self.elements(allLoads, "NonConformLoad", "Non Conform Loads", eqs["cim:NonConformLoad"]);
                // Compensators
                let allComps = self.createTopContainer(cimNetwork, "Compensator", "Compensators", allCompensators);
                self.elements(allComps, "LinearShuntCompensator", "Linear", eqs["cim:LinearShuntCompensator"]);
                self.nlCompensators(allComps, eqs["cim:NonlinearShuntCompensator"]);
                // Busbars
                self.elements(cimNetwork, "BusbarSection", "Nodes", allBusbarSections);
                // Transformers
                self.powerTransformers(cimNetwork, eqs["cim:PowerTransformer"]);
                // ====================================================================
                // =========================== "Containers" ===========================
                // ====================================================================
                self.geoRegions(cimContainers, allGeoRegions);
                self.substations(cimContainers, allContainers["cim:Substation"]);
                let lineEnter = self.elements(cimContainers, "Line", "Lines", allContainers["cim:Line"]);
                self.createDeleteMenu(lineEnter);
                let allGenUnits = self.createTopContainer(cimContainers, "GeneralGeneratingUnit", "Generating Units", allGeneratingUnits["cim:GeneratingUnit"].concat(allGeneratingUnits["cim:ThermalGeneratingUnit"]));
                self.elements(allGenUnits, "GeneratingUnit", "General Units", allGeneratingUnits["cim:GeneratingUnit"]);
                self.elements(allGenUnits, "ThermalGeneratingUnit", "Thermal Units", allGeneratingUnits["cim:ThermalGeneratingUnit"]);
                // ====================================================================
                // ===================== "Curves and Regulations" =====================
                // ====================================================================
                self.elements(cimCurvesAndRegs, "LoadResponseCharacteristic", "Load Response Characteristics", allLoadResponses["cim:LoadResponseCharacteristic"]);
                let tccEnter = self.elements(cimCurvesAndRegs, "TapChangerControl", "Tap Changer Controls", noDiagObjs["cim:TapChangerControl"]);
                self.createDeleteMenu(tccEnter);
                let rcEnter = self.elements(cimCurvesAndRegs, "RegulatingControl", "Regulating Controls", noDiagObjs["cim:RegulatingControl"]);
                self.createDeleteMenu(rcEnter);
                // ====================================================================
                // ======================= "Operational Limits" =======================
                // ====================================================================
                let limTypesEnter = self.elements(cimLimits, "OperationalLimitType", "Operational Limit Types", noDiagObjs["cim:OperationalLimitType"]);
                self.createDeleteMenu(limTypesEnter);
                
                // add buttons
                self.createAddButton(cimBases, "BaseVoltage");
                self.createAddButton(cimContainers, "Substation");
                self.createAddButton(cimContainers, "GeographicalRegion");
                self.createAddButton(cimContainers, "Line");
                self.createAddButton(cimContainers, "GeneratingUnit");
                self.createAddButton(cimContainers, "ThermalGeneratingUnit");
                self.createAddButton(cimCurvesAndRegs, "LoadResponseCharacteristic");
                self.createAddButton(cimLimits, "OperationalLimitType");
            };
        },
     
        render(diagramName) {     
            self.props.model.selectDiagram(decodeURI(diagramName));
            self.state.diagramName = decodeURI(diagramName);
            // the toggling of this checkbox actually renders the tree
            document.getElementById("showAllObjects").checked = true;
            document.getElementById("showAllObjects").dispatchEvent(new MouseEvent("click"));
        },

        geoRegions(tab, allGeoRegions) {
            let geoEnter = self.elements(tab, "GeographicalRegion", "Geographical Regions", allGeoRegions);
            geoEnter.each(function(d, i) {
                let subGeos = self.props.model.getTargets(
                    [d],
                    "GeographicalRegion.Regions");
                self.subGeoRegions(
                    d3.select(this),
                    subGeos);
                self.subAddButton(
                    d3.select(this),
                    "SubGeographicalRegion",
                    "cim:SubGeographicalRegion.Region");
            });
            self.createDeleteMenu(geoEnter);
        },

        subGeoRegions(geoG, subGeos) {
            let geo = geoG.data()[0];
            let subGeoEnter = self.elements(
                geoG,
                self.props.model.ID(geo) + "SubGeographicalRegion",
                "Sub-Geographical Regions",
                subGeos);
            self.createDeleteMenu(subGeoEnter);     
        },

        substations(tab, allSubstations) {
            let subEnter = self.elements(tab, "Substation", "Substations", allSubstations);
            subEnter.each(function(d, i) {
                let vlevs = self.props.model.getTargets(
                    [d],
                    "Substation.VoltageLevels");
                self.voltageLevels(
                    d3.select(this),
                    vlevs);
                self.subAddButton(
                    d3.select(this),
                    "VoltageLevel",
                    "cim:VoltageLevel.Substation");
            });
            self.createDeleteMenu(subEnter);
        },

        voltageLevels(subG, vlevs) {
            let sub = subG.data()[0];
            let vlEnter = self.elements(
                subG,
                self.props.model.ID(sub) + "VoltageLevel",
                "Voltage Levels",
                vlevs);
            vlEnter.each(function(d, i) {
                let bays = self.props.model.getTargets(
                    [d],
                    "VoltageLevel.Bays");
                self.bays(
                    d3.select(this),
                    bays);
                self.subAddButton(
                    d3.select(this),
                    "Bay",
                    "cim:Bay.VoltageLevel");
            });
            self.createDeleteMenu(vlEnter);
        },

        bays(vlG, bays) {
            let vl = vlG.data()[0];
            let bayEnter = self.elements(
                vlG,
                self.props.model.ID(vl) + "Bay",
                "Bays",
                bays);
            self.createDeleteMenu(bayEnter);
        },

        powerTransformers(tab, allTrafos) {
            let trafoEnter = self.elements(tab, "PowerTransformer", "Transformers", allTrafos);
            trafoEnter.each(function(d, i) {
                // trafo ends
                let trafoEnds = self.props.model.getTargets(
                    [d],
                    "PowerTransformer.PowerTransformerEnd");
                let trafoEndsEnter = self.elements(
                    d3.select(this),
                    self.props.model.ID(d) + "PowerTransformerEnd",
                    "Transformer Windings",
                    trafoEnds);
                // tap changer(s)
                trafoEndsEnter.each(function(d, i) {
                    let tcs = self.props.model.getTargets([d], "TransformerEnd.RatioTapChanger");
                    self.tapChangers(d3.select(this), tcs);
                });
            });
        },

        nlCompensators(tab, allNLCs) {
            let nlcEnter = self.elements(tab, "NonlinearShuntCompensator", "Nonlinear", allNLCs);
            nlcEnter.each(function(d, i) {
                // nlc points
                let nlcPoints = self.props.model.getTargets(
                    [d],
                    "NonlinearShuntCompensator.NonlinearShuntCompensatorPoints");
                self.nlCompensatorPoints(d3.select(this), nlcPoints);
                self.subAddButton(
                    d3.select(this),
                    "NonlinearShuntCompensatorPoint",
                    "cim:NonlinearShuntCompensatorPoint.NonlinearShuntCompensator");
            });
        },

        nlCompensatorPoints(nlcG, nlcPoints) {
            let nlc = nlcG.data()[0];
            let nlcPointsEnter = self.elements(
                nlcG,
                self.props.model.ID(nlc) + "NonlinearShuntCompensatorPoint",
                "Points",
                nlcPoints, true); 
            self.createDeleteMenu(nlcPointsEnter);
        },

        tapChangers(trafoG, tcs) {
            let trafo = trafoG.data()[0];
            let tcEnter = self.elements(
                trafoG,
                self.props.model.ID(trafo) + "RatioTapChanger",
                "Ratio Tap Changer",
                tcs);
            self.createDeleteMenu(tcEnter);
        },

        limitSets(eqG, allLimits) {
            const eq = eqG.data()[0];
            let limSetEnter = self.elements(eqG, self.props.model.ID(eq) + "OperationalLimitSet", "Operational Limit Sets", allLimits);
            limSetEnter.each(function(d, i) {
                // limits
                let lims = self.props.model.getTargets(
                    [d],
                    "OperationalLimitSet.OperationalLimitValue");
                self.limits(d3.select(this), lims);
                self.subAddButton(
                    d3.select(this),
                    "VoltageLimit",
                    "cim:OperationalLimit.OperationalLimitSet");
                self.subAddButton(
                    d3.select(this),
                    "CurrentLimit",
                    "cim:OperationalLimit.OperationalLimitSet");
                self.subAddButton(
                    d3.select(this),
                    "ActivePowerLimit",
                    "cim:OperationalLimit.OperationalLimitSet");
                self.subAddButton(
                    d3.select(this),
                    "ApparentPowerLimit",
                    "cim:OperationalLimit.OperationalLimitSet");
            });
            self.createDeleteMenu(limSetEnter);
        },

        limits(setG, lims) {
            let opset = setG.data()[0];
            let vLims = lims.filter(el => self.props.model.schema.isA("VoltageLimit", el));
            let iLims = lims.filter(el => self.props.model.schema.isA("CurrentLimit", el));
            let pLims = lims.filter(el => self.props.model.schema.isA("ActivePowerLimit", el));
            let sLims = lims.filter(el => self.props.model.schema.isA("ApparentPowerLimit", el));
            let vLimEnter = self.elements(
                setG,
                self.props.model.ID(opset) + "VoltageLimit",
                "Voltage limits",
                vLims);
            let iLimEnter = self.elements(
                setG,
                self.props.model.ID(opset) + "CurrentLimit",
                "Current limits",
                iLims);
            let pLimEnter = self.elements(
                setG,
                self.props.model.ID(opset) + "ActivePowerLimit",
                "Active power limits",
                pLims);
            let sLimEnter = self.elements(
                setG,
                self.props.model.ID(opset) + "ApparentPowerLimit",
                "Apparent power limits",
                sLims);
            self.createDeleteMenu(vLimEnter);
            self.createDeleteMenu(iLimEnter);
            self.createDeleteMenu(pLimEnter);
            self.createDeleteMenu(sLimEnter);
        },

        createTopContainer(cimNetwork, name, printName, data) {
            let elementsTopContainer = cimNetwork.select("li." + name + "s");
            let elements = elementsTopContainer.select("ul#" + name + "sList");
            if (elementsTopContainer.empty()) {
                elementsTopContainer = cimNetwork
                    .append("li")
                    .attr("class", name + "s" + " list-group-item d-flex justify-content-between cim-parent-container");
                let listContainer = elementsTopContainer.append("div");
                listContainer.append("a")
                                    .attr("class", "btn btn-primary btn-sm")
                                    .attr("role", "button")
                                    .attr("data-bs-toggle", "collapse")
                                    .attr("href", "#" + name + "sList")
                                    .html(printName);
                elementsTopContainer.append("h4")
                                    .append("span")
                                    .attr("class", "badge bg-primary rounded-pill")
                                    .html(0);
                elements = listContainer
                    .append("ul")
                    .attr("id", name + "sList")
                    .attr("class", "collapse");
                elementsTopContainer.on("click", function(event) {
                    if (event.target === this) {
                        self.goToBasePath();
                    }
                });
            } 
            return elements;
        },

        // add button for non-graphical objects
        createAddButton(cimContainer, name) {
            let elementsTopContainer = cimContainer.select("li." + name + "s");
            let elements = elementsTopContainer.select("ul#" + name + "sList");
            let addBtn = elementsTopContainer.select("ul#" + name + "sList > button.cim-add-btn");
            if (addBtn.empty() === true) {
                addBtn = elements
                    .insert("li", ":first-child")
                    .append("button")
                    .attr("class", "btn btn-default btn-sm cim-add-btn")
                    .attr("type", "submit");
                addBtn.html("<span class=\"fas fa-plus\" aria-hidden=\"true\"></span> Add");
                addBtn.on("click.add", function() {
                    let newObject = self.props.model.createObject("cim:" + name);
                    self.props.model.addToActiveDiagram(newObject, []);
                });
            }
        },

        subAddButton(cimContainer, type, link) {
            let parent = cimContainer.data()[0];
            let name = self.props.model.ID(parent) + type;
            let elementsTopContainer = cimContainer.select("li." + name + "s");
            let elements = elementsTopContainer.select("ul#" + name + "sList");
            let addBtn = elementsTopContainer.select("ul#" + name + "sList > button.cim-add-btn");
            if (addBtn.empty() === true) {
                addBtn = elements
                    .insert("li", ":first-child")
                    .append("button")
                    .attr("class", "btn btn-default btn-sm cim-add-btn")
                    .attr("type", "submit");
                addBtn.html("<span class=\"fas fa-plus\" aria-hidden=\"true\"></span> Add");
                addBtn.on("click.add", function() {
                    let newObject = self.props.model.createObject("cim:" + type);
                    self.props.model.setLink(newObject, link, parent);
                    self.props.model.addToActiveDiagram(newObject, []);
                });
            }
        },

        // delete menu for non graphic objects
        createDeleteMenu(selection) {
            let btnSel = selection.selectAll(function() { return this.parentNode.childNodes; }).filter("button.cim-object-btn");
            btnSel.on("contextmenu", menu);
        },

        elements(cimNetwork, name, printName, data) {
            let elementsTopContainer = cimNetwork.select("li." + name + "s");
            let elements = elementsTopContainer.select("ul#" + name + "sList");
            if (elementsTopContainer.empty() === true) {
                elementsTopContainer = cimNetwork
                    .append("li")
                    .attr("class", name + "s" + " list-group-item d-flex justify-content-between");
                let listContainer = elementsTopContainer.append("div");
                listContainer.append("a")
                            .attr("class", "btn btn-primary btn-sm")
                            .attr("role", "button")
                            .attr("data-bs-toggle", "collapse")
                            .attr("href", "#" + name + "sList")
                            .html(printName);
                elementsTopContainer.append("h4")
                                    .append("span")
                                    .attr("class", "badge bg-primary rounded-pill")
                                    .html(0);
                elementsTopContainer.on("click", function(event) {
                    if (event.target === this) {
                        self.goToBasePath();
                    }
                });
                elements = elementsTopContainer
                    .select("div")
                    .append("ul")
                    .attr("id", name + "sList")
                    .attr("class", "collapse");
            } 

            let elementTopContainer = elements
                    .selectAll("li." + name)
                    .data(data, function(d) {
                        return self.props.model.ID(d);
                    })
                    .enter()
                    .append("li")
                    .attr("class", name + " CIM-object").on("click", function(event) {
                        if (event.target === this) {
                            self.goToBasePath();
                        }
                    });
            // Add two buttons: one for expanding attributes and links,
            // the other for navigation
            elementTopContainer
                .append("a")
                .attr("class", "btn btn-outline-secondary btn-sm cim-expand-object")
                .attr("role", "button")
                .attr("data-bs-toggle", "collapse")
                .attr("href", function(d) {
                    return "#" + self.props.model.ID(d);
                }).on("click", function (event, d) {
                    event.preventDefault();
                    // if necessary, generate attributes and links
                    let elementEnter = d3.select(this.parentNode).select("ul");
                    if (elementEnter.selectAll("li.attribute").size() === 0) {
                        self.generateAttrsAndLinks(elementEnter);
                    }
                })
                .html("<span class=\"fas fa-plus\" aria-hidden=\"true\"></span>");
            elementTopContainer
                .append("button")
                .attr("class", "btn btn-primary btn-sm cim-object-btn")
                .on("click", function (event, d) {
                    // change address to 'this object'
                    let hashComponents = window.location.hash.substring(1).split("/");
                    let basePath = hashComponents[0] + "/" + hashComponents[1] + "/" + hashComponents[2];
                    if (window.location.hash.substring(1) !== basePath + "/" + self.props.model.ID(d)) {
                        route.router.push(basePath + "/" + self.props.model.ID(d));
                    }
                })
                .html(function (d) {
                    let name = self.props.model.getAttribute(d, "cim:IdentifiedObject.name");
                    if (typeof(name) !== "undefined") {
                        return name.innerHTML;
                    }
                    return "unnamed";
                })
                .attr("draggable", "true")
                .on("dragstart", function(event, d) {
                    event.dataTransfer.setData("text/plain", self.props.model.ID(d));
                });
            
            let elementEnter = elementTopContainer
                .append("ul")
                .attr("id", function(d) {
                    return self.props.model.ID(d);
                })
                .attr("class", "collapse CIM-object-list");
            // update element count
            let elementCount = parseInt(elementsTopContainer.select(":scope > h4 > span").html());
            elementCount = elementCount + elementEnter.size();
            elementsTopContainer.select(":scope > h4 > span").html(elementCount);
            // update also the top containers (if any)
            const tcNode = elementsTopContainer.node();
            if (tcNode.closest(".CIM-object") === null) {
                let parent = tcNode.closest("li.cim-parent-container");
                while (parent !== null) {
                    let span = parent.querySelector(":scope>h4>span");
                    let elementCount = parseInt(span.innerHTML);
                    elementCount = elementCount + elementEnter.size();
                    span.innerHTML = elementCount;    
                    parent = parent.parentNode.closest("li.cim-parent-container");
                }
            }

            return elementEnter;
        },

        generateAttrsAndLinks(elementEnter) {
            // add attributes
            let elementDiv = createTopDivs(document.getElementById("sshInput").checked === false, "EQ");
            self.generateAttributes(elementDiv);
            let sshDiv = createTopDivs(document.getElementById("sshInput").checked === true, "SSH");
            self.generateAttributes(sshDiv);
            // add links
            let eqLinks = createLinkDivs(document.getElementById("sshInput").checked === false, "EQ");
            self.generateLinks(eqLinks);
            let sshLinks = createLinkDivs(document.getElementById("sshInput").checked === true, "SSH");
            self.generateLinks(sshLinks);
            // For every subclass of Equipment we provide also its operational limits
            const d = elementEnter.datum();
            if (self.props.model.schema.isA("Equipment", d)) {
                let terms = self.props.model.getTerminals([d]);
                let limSets = self.props.model.getTargets([d], "Equipment.OperationalLimitSet");
                limSets = limSets.concat(self.props.model.getTargets(terms, "ACDCTerminal.OperationalLimitSet"));
                self.limitSets(elementEnter, limSets);
            }
            
            function createTopDivs(visible, profile) {
                let elementDiv = elementEnter
                    .selectAll("li.attribute." + profile)
                    .data(function(d) {
                        let attrs = self.props.model.schema.getSchemaAttributes(d.localName, profile);
                        let existing = elementEnter.selectAll("li.attribute > div > span.cim-tree-attribute-name").nodes().map(node => node.textContent);
                        attrs = attrs.filter(function(attr) {
                            let attrName = attr.attributes[0].value.substring(1).split(".")[1];
                            return existing.indexOf(attrName) < 0;
                        });
                        return attrs.filter(el => el.attributes[0].value !== "#IdentifiedObject.mRID"); 
                    })
                    .enter()
                    .append("li")
                    .attr("class", getClasses(visible, profile))
                    .attr("title", function(d) {
                        let about = d.attributes.getNamedItem("rdf:about").value;
                        let fullName = about.split(".")[1];
                        let comment = [].filter.call(d.children, function(el) {
                            return el.nodeName === "rdfs:comment"
                        });
                        if (comment.length > 0) {
                            return fullName + " - " + comment[0].textContent;
                        }
                        return fullName;
                    })
                    .append("div").attr("class", "input-group");
                return elementDiv;
            };

            function createLinkDivs(visible, profile) {
                let elementLink = elementEnter
                    .selectAll("li.link." + profile)
                    .data(function(d) {
                        // links we don't want to show in the tree
                        let hiddenLinks = [
                            "#NonlinearShuntCompensatorPoint.NonlinearShuntCompensator",
                            "#TransformerEnd.Terminal",
                            "#PowerTransformerEnd.PowerTransformer",
                            "#RatioTapChanger.TransformerEnd",
                            "#RegulatingControl.Terminal",
                            "#Measurement.Terminal",
                            "#Measurement.PowerSystemResource",
                            "#Discrete.ValueAliasSet",
                            "#OperationalLimitSet.Terminal",
                            "#OperationalLimitSet.Equipment",
                            "#OperationalLimit.OperationalLimitSet",
                            "#SubGeographicalRegion.Region",
                            "#VoltageLevel.Substation",
                            "#Bay.VoltageLevel"];
                        return self.props.model.schema.getSchemaLinks(d.localName, profile)
                                .filter(el => self.props.model.getAttribute(el, "cims:AssociationUsed").textContent === "Yes")
                                .filter(el => hiddenLinks.indexOf(el.attributes[0].value) < 0)
                    })
                    .enter()
                    .append("li")
                    .attr("class", getClasses(visible, profile))
                    .attr("title", function(d) {
                        let about = d.attributes.getNamedItem("rdf:about").value;
                        let fullName = about.split(".")[1];
                        let comment = [].filter.call(d.children, function(el) {
                            return el.nodeName === "rdfs:comment"
                        });
                        if (comment.length > 0) {
                            return fullName + " - " + comment[0].textContent;
                        }
                        return fullName;
                    })
                    .append("div").attr("class", "input-group");
                return elementLink;
            };

            function getClasses(visible, profile) {
                return function(d) {
                    // Every attribute has class "attribute" and either "EQ"
                    // or "SSH" depending on its profile.
                    let ret = "attribute " + profile;
                    // ENTSO-E attributes have class "entsoe".
                    let about = d.attributes.getNamedItem("rdf:about").value;
                    if (about.startsWith("#") === false) {
                        ret = ret + " entsoe";
                    }
                    // If profile is "EQ" we add also the stereotype, in order to
                    // distinguish between core, operation, short circuit.
                    let stereotype = null;
                    if (profile === "EQ") {
                        stereotype = self.props.model.schema.getSchemaStereotype(d);
                        if (stereotype !== null) {
                            ret = ret + " " + stereotype;
                        }
                    }
                    // In some cases we don't want to show the attribute.
                    if ((stereotype === "Operation" && self.props.model.getMode() === "BUS_BRANCH") ||
                        (visible === false)) {
                        ret = ret + " d-none";
                    } 
                    return ret;
                };
            };
        },

        generateAttributes(elementDiv) {
            elementDiv.append("span").attr("class", "input-group-text cim-tree-attribute-name")
                    .html(function (d) {
                        let about = d.attributes.getNamedItem("rdf:about").value;
                        let fullName = about.split(".")[1];
                        if (fullName.length > 20) {
                            fullName = fullName.substring(0, 20) + "..." ;
                        }
                        return fullName; 
                    });
            // String attributes 
            elementDiv.filter(function(d) {
                let attrType = self.props.model.schema.getSchemaAttributeType(d);
                return attrType[0] === "#String";
            }).append("input")
                    .attr("class", "form-control")
                    .each(setValueFromModel)
                    .attr("type", "text")
                    .on("input", attrInput);
            // Integer attributes
            elementDiv.filter(function(d) {
                let attrType = self.props.model.schema.getSchemaAttributeType(d);
                return attrType[0] === "#Integer";
            }).append("input")
                    .attr("class", "form-control")
                    .each(setIntValueFromModel)
                    .attr("type", "number")
                    .on("input", attrInput);
            // Float attributes
            let floats = elementDiv.filter(function(d) {
                let attrType = self.props.model.schema.getSchemaAttributeType(d);
                return (attrType[0] === "#Float" || attrType[0] === "#Decimal");
            });
            floats.append("input")
                .attr("class", "form-control")
                .each(setFloatValueFromModel)
                .attr("type", "number")
                .attr("step", "0.00001")
                .on("input", attrInput);
            floats.append("span").attr("class", "input-group-text cim-tree-attribute-uom")
                .html(function (d) {
                    let attrType = self.props.model.schema.getSchemaAttributeType(d);
                    if (attrType[2] === "none") {
                        return attrType[1];
                    }
                    return attrType[2] + attrType[1];
                });
            // Boolean attributes
            let elementBool = elementDiv.filter(function(d) {
                let attrType = self.props.model.schema.getSchemaAttributeType(d);
                return attrType[0] === "#Boolean";
            });
            let elementBoolBtn = elementBool.append("button").attr("type", "button")
                                            .attr("class", "btn btn-outline-secondary dropdown-toggle cim-tree-dropdown-toggle")
                                            .attr("data-bs-toggle", "dropdown")
                                            .attr("aria-expanded", "false");
            elementBoolBtn.append("span").attr("class", "boolVal").each(setBoolValueFromModel);
            let elementBoolList = elementBool.append("ul").attr("class", "dropdown-menu dropdown-menu-end");
            elementBoolList.append("li").append("a").attr("class", "dropdown-item").text("true").on("click", setBoolAttr);
            elementBoolList.append("li").append("a").attr("class", "dropdown-item").text("false").on("click", setBoolAttr);
            // DateTime attributes (note: such input types are not supported by Firefox) 
            elementDiv.filter(function(d) {
                let attrType = self.props.model.schema.getSchemaAttributeType(d);
                return attrType[0] === "#DateTime";
            }).append("input")
                    .attr("class", "form-control")
                    .each(setValueFromModel)
                    .attr("type", "datetime-local") 
                    .on("input", attrInput);
            // Enum attributes
            let elementEnum = elementDiv.filter(function(d) {
                return self.props.model.schema.isEnum(d);
            });
            let elementEnumBtn = elementEnum.append("button").attr("type", "button")
                                            .attr("class", "btn btn-outline-secondary dropdown-toggle cim-tree-dropdown-toggle")
                                            .attr("data-bs-toggle", "dropdown")
                                            .attr("aria-expanded", "false");
            elementEnumBtn.append("span").attr("class", "enumVal").each(setEnumValueFromModel);
            let elementEnumList = elementEnum.append("ul").attr("class", "dropdown-menu dropdown-menu-end");
            elementEnumList
                .selectAll("li")
                .data(function(d) {
                    return self.props.model.schema.getSchemaEnumValues(d);
                })
                .enter()
                .append("li")
                .append("a")
                .on("click", setEnumAttr)
                .attr("class", "dropdown-item")
                .text(function(d) {
                    return d;
                });
            function setValueFromModel(d) {
                let object = d3.select(this.closest("li.attribute").parentNode).data()[0];
                let value = self.props.model.getAttribute(object, "cim:" + d.attributes[0].value.substring(1));
                if (typeof(value) !== "undefined") {
                    this.value = value.innerHTML;
                } else { 
                    d3.select(this).attr("placeholder", "none");
                }
            };
            function setIntValueFromModel(d) {
                let object = d3.select(this.closest("ul")).data()[0]; 
                let value = self.props.model.getAttribute(object, "cim:" + d.attributes[0].value.substring(1));
                if (typeof(value) !== "undefined") {
                    this.value = parseInt(value.innerHTML);
                } else { 
                    d3.select(this).attr("placeholder", "none");
                }
            };
            function setFloatValueFromModel(d) {
                let object = d3.select(this.closest("ul")).data()[0]; 
                let value = self.props.model.getAttribute(object, "cim:" + d.attributes[0].value.substring(1));
                if (typeof(value) !== "undefined") {
                    this.value = parseFloat(value.innerHTML).toFixed(5);
                } else { 
                    d3.select(this).attr("placeholder", "none");
                }
            };
            function setBoolValueFromModel(d) {
                let object = d3.select(this.closest("li.attribute").parentNode).data()[0];
                let value = self.props.model.getAttribute(object, "cim:" + d.attributes[0].value.substring(1));
                if (typeof(value) !== "undefined") {
                    d3.select(this).text(value.innerHTML);
                } else { 
                    d3.select(this).text("none");
                }
            };
            function setEnumValueFromModel(d) {
                let object = d3.select(this.closest("li.attribute").parentNode).data()[0];
                let value = self.props.model.getEnum(object, "cim:" + d.attributes[0].value.substring(1));
                if (typeof(value) !== "undefined") {
                    d3.select(this).text(value);
                } else { 
                    d3.select(this).text("none");
                }
            };
            // set a boolean attribute according to user input
            function setBoolAttr(event, d) {
                // change the element's text
                let value = this.textContent;
                this.closest("div.input-group").querySelector(":scope>button>span.boolVal").textContent = value;
                let object = d3.select(this.closest("li.attribute").parentNode).data()[0];
                let attrName = "cim:" + d.attributes[0].value.substring(1);
                // update the model
                self.props.model.setAttribute(object, attrName, value);
            };
            // set an enum attribute according to user input
            function setEnumAttr(event, d) {
                // change the element's text
                this.closest("div.input-group").querySelector(":scope>button>span.enumVal").textContent = d;
                let object = d3.select(this.closest("li.attribute").parentNode).data()[0];
                let attr = d3.select(this.closest("li.attribute")).data()[0];
                let attrName = "cim:" + attr.attributes[0].value.substring(1);
                let value = self.props.model.schema.getSchemaEnumName(attr) + "." + d;
                // update the model
                self.props.model.setEnum(object, attrName, value);
            };
            function attrInput(event, d) {
                let object = d3.select(this.closest("ul")).data()[0];
                let about = d.attributes.getNamedItem("rdf:about").value;
                let ns = "cim:";
                if (about.startsWith("#") === false) {
                    ns = "entsoe:";
                }
                about = about.substring(about.indexOf("#") + 1); 
                let attrName = ns + about;
                self.props.model.setAttribute(object, attrName, this.value);
            };
        },

        generateLinks(elementLink) {
            elementLink.attr("class", "input-group").append("span").attr("class", "input-group-text cim-tree-attribute-name")
                        .html(function (d) {
                            let about = d.attributes.getNamedItem("rdf:about").value;
                            let fullName = about.split(".")[1];
                            if (fullName.length > 20) {
                                fullName = fullName.substring(0, 20) + "..." ;
                            }
                            return fullName; 
                        });
            let elementLinkBtn = elementLink.append("div").attr("class", "btn-group cim-tree-btn-group");
            elementLinkBtn.append("button")
                        .attr("class","btn btn-outline-secondary cimLinkBtn")
                        .attr("type", "submit")
                        .on("click", function(event, d) {
                            let targetUUID = "#" + d3.select(this).attr("cim-target"); 
                            let hashComponents = window.location.hash.substring(1).split("/");
                            let basePath = hashComponents[0] + "/" + hashComponents[1] + "/" + hashComponents[2];
                            route.router.push(basePath + "/" + targetUUID.substring(1));
                        })
                        .attr("cim-target", function(d) {
                            let source = d3.select(this.closest("ul")).data()[0];
                            let targetObj = self.props.model.getTargets(
                                [source],
                                d.attributes[0].value.substring(1))[0];
                            if (typeof(targetObj) === "undefined") {
                                return "none";
                            }
                            return self.props.model.ID(targetObj);
                        })
                        .html(function (d) {
                            let targetObj = self.props.model.getObject(d3.select(this).attr("cim-target"));
                            if (typeof(targetObj) === "undefined") {
                                d3.select(this).attr("disabled", "disabled");
                                return "none";
                            }
                            let name = self.props.model.getAttribute(targetObj, "cim:IdentifiedObject.name");
                            if (typeof(name) !== "undefined") {
                                return name.innerHTML;
                            }
                            return "unnamed";
                        });
            elementLinkBtn.append("button")
                        .attr("class","btn btn-outline-secondary")
                        .attr("type", "submit")
                        .on("click", function (event, d) {
                            // handle the modification of links
                            let linkToChange = d3.select(this.parentNode);
                            let range = self.props.model.schema.getLinkRange(d);
                            let treeItems = d3.select(".tree").selectAll(".tab-pane > .list-group > .list-group-item > div > ul");
                            // we divide the tree items into two partitions: the
                            // possible targets of the link and the non-targets.
                            // TODO: check if there is a more efficient calculation
                            // for the two partitions.
                            let targets = treeItems.filter(function(d) {
                                let ret = false;
                                let cimObj = d3.select(this).select(".CIM-object");
                                if (cimObj.size() > 0) {
                                    ret = self.props.model.schema.isA(range, cimObj.datum()) === true; 
                                }
                                return ret;
                            });
                            let nonTargets = treeItems.filter(function(d) {
                                let ret = true;
                                let cimObj = d3.select(this).select(".CIM-object");
                                if (cimObj.size() > 0) {
                                    ret = self.props.model.schema.isA(range, cimObj.datum()) === false; 
                                }
                                return ret; 
                            });                           
                            self.enterSetLinkMode(linkToChange, targets, nonTargets);
                        })
                        .html("change");
            elementLinkBtn.append("button")
                        .attr("class","btn btn-outline-secondary")
                        .attr("type", "submit")
                        .attr("id", "cimRemoveBtn")
                        .on("click", function (event, d) {
                            let source = d3.select(this.closest("ul")).data()[0];
                            let linkName = "cim:" + d.attributes[0].value.substring(1);
                            let target = self.props.model.getObject(this.parentNode.querySelector("[cim-target]").getAttribute("cim-target"));
                            self.props.model.removeLink(source, linkName, target);
                        })
                        .html(function() {
                            let target = self.props.model.getObject(this.parentNode.querySelector("[cim-target]").getAttribute("cim-target"));
                            if (typeof(target) === "undefined") {
                                d3.select(this).attr("disabled", "disabled");
                            }
                            return "remove";
                        });
        },

        setLink(linkToChange, source) {
            let target = d3.select(linkToChange.node().closest("ul")).data()[0];
            let targetUUID = self.props.model.ID(target);
            if (source !== null) {
                let targetLink = linkToChange.data()[0];
                let targetLinkName = "cim:" + targetLink.attributes[0].value.substring(1);
                self.props.model.setLink(target, targetLinkName, source);
            }
            let hashComponents = window.location.hash.substring(1).split("/");
            let basePath = hashComponents[0] + "/" + hashComponents[1] + "/" + hashComponents[2];
            route.router.push(basePath + "/" + targetUUID);
        },

        // Enter mode for editing links.
        enterSetLinkMode(linkToChange, targets, nonTargets) {
            self.state.mode = "setLinks";
            document.getElementById("tree-link-dialog").classList.remove("d-none");
            document.getElementById("tree-controls").classList.add("d-none");
            targets.each(function(d) {
                let cimObjs = d3.select(this).selectAll(".CIM-object");
                cimObjs.select("button.cim-object-btn").classed("btn-primary", false).classed("btn-outline-dark", true);
                let checkBtn = cimObjs
                    .insert("button", ":first-child")
                    .attr("class", "btn btn-outline-dark btn-sm cim-check-btn")
                    .attr("type", "submit").on("click", function() {
                        d3.select(this.firstChild).attr("class", "far fa-check-square");
                        let source = d3.select(this).datum();
                        self.setLink(linkToChange, source);
                        self.exitSetLinkMode();
                    });
                checkBtn.append("span")
                        .attr("class", "far fa-square");
                cimObjs.selectAll("a.cim-expand-object").classed("d-none", true);
            });
            
            nonTargets.each(function(d) {
                this.parentNode.parentNode.classList.add("d-none");
                this.parentNode.parentNode.classList.remove("d-flex");
            });

            document.querySelectorAll(".tab-content > .tab-pane > ul").forEach(function(el) {
                const tab = el.parentNode.getAttribute("id") + "Tab";
                if (el.querySelectorAll(":scope > li.d-flex").length === 0) {
                    document.getElementById(tab).classList.add("d-none");
                } else {
                    bootstrap.Tab.getInstance(document.querySelector("#" + tab)).show();
                }
            });
            
            // handle escape key
            d3.select("body").on("keyup.tree", function(event) {
                if (event.keyCode === 27) { // "Escape"
                    self.exitSetLinkMode();
                    self.setLink(linkToChange, null);
                }
            });
            // setup link dialog button
            d3.select("#tree-link-dialog-cancel").on("click", function() {
                self.exitSetLinkMode();
                self.setLink(linkToChange, null);
            });
        },

        // Exit mode for editing links.
        exitSetLinkMode() {
            self.state.mode = "default";
            document.getElementById("tree-link-dialog").classList.add("d-none");
            document.getElementById("tree-controls").classList.remove("d-none");
            let treeItems = d3.select(".tree").selectAll(".tab-pane > .list-group > .list-group-item > div > ul");
            treeItems.each(function(d) {
                let cimObjs = d3.select(this).selectAll(".CIM-object");
                cimObjs.selectAll("button.cim-check-btn").remove();
                cimObjs.select("button.cim-object-btn").classed("btn-primary", true).classed("btn-outline-dark", false);
                cimObjs.selectAll("a.cim-expand-object").classed("d-none", false);
                this.parentNode.parentNode.classList.add("d-flex");
                this.parentNode.parentNode.classList.remove("d-none");
            });

            document.querySelectorAll(".tab-content > .tab-pane > ul").forEach(function(el) {
                const tab = el.parentNode.getAttribute("id") + "Tab";
                document.getElementById(tab).classList.remove("d-none");
            });

            d3.select("body").on("keyup.tree", null);
            d3.select("#tree-link-dialog-cancel").on("click", null);
        },

        moveTo(uuid) {
            if (typeof(uuid) === "undefined") {
                return;
            }
            let target = null, targetChild = null;
            let hoverD = self.props.model.getObject(uuid);
            if (typeof(hoverD) === "undefined") {
                return;
            }
            // handle nodes
            if (hoverD.nodeName === "cim:ConnectivityNode" || hoverD.nodeName === "cim:TopologicalNode") {
                // let's try to get a busbar section
                let busbarSection = self.props.model.getBusbar(hoverD);
                if (busbarSection === null) {
                    return;
                }
                uuid = self.props.model.ID(busbarSection);
            } 
            targetChild = d3.select(".tree").select("#" + uuid).node();
            if (targetChild === null) {
                return;
            }
            target = targetChild.parentNode;
            d3.select(".tree").selectAll(".btn-danger").classed("btn-danger", false).classed("btn-primary", true);
            // show the relevant tab
            const tabId = target.closest("div.tab-pane").getAttribute("id") + "Tab";
            if (document.getElementById(tabId).classList.contains("active")) {
                self.scrollTo("#" + uuid);
            } else {
                function shown(event) {
                    self.scrollTo("#" + uuid);
                    this.removeEventListener("shown.bs.tab", shown);
                };
                document.querySelector("#" + tabId).addEventListener("shown.bs.tab", shown);
            }
            bootstrap.Tab.getInstance(document.querySelector("#" + tabId)).show();
            d3.select(target).select("button.cim-object-btn").classed("btn-danger", true).classed("btn-primary", false);
        },
     
        deleteObject(objectUUID) {
            let cimObject = d3.select("div.tree").select("ul#" + objectUUID).node();
            if (cimObject !== null) {
                let cimObjectContainer = cimObject.parentNode;
                // update element count
                cimObjectContainer
                .closest("li.list-group-item")
                .querySelectorAll(":scope>h4>span")
                .forEach(function(element) {
                        let elementCount = parseInt(element.innerHTML);
                        elementCount = elementCount - 1;
                        element.innerHTML = elementCount;
                });

                let parent = cimObjectContainer.closest("li.cim-parent-container");
                while (parent !== null) {
                    let span = parent.querySelector(":scope>h4>span");
                    let elementCount = parseInt(span.innerHTML);
                    elementCount = elementCount - 1;
                    span.innerHTML = elementCount;    
                    parent = parent.parentNode.closest("li.cim-parent-container");
                }

                // remove object
                cimObjectContainer.remove();
            }
        },

        scrollTo(targetUUID) {
            let parent = document.querySelector(targetUUID).parentNode.closest(".collapse:not(.show)");
            if (parent === null) {
                scrollToVisible(targetUUID);
            }
            while (parent !== null) {
                function shown(event) {
                    event.stopPropagation();
                    let elementEnter = d3.select(this.parentNode).filter(".CIM-object").select("ul");
                    if (elementEnter.selectAll("li.attribute").size() === 0) {
                        self.generateAttrsAndLinks(elementEnter);
                    }
                    scrollToVisible(targetUUID);
                    this.removeEventListener("shown.bs.collapse", shown);
                };
                parent.addEventListener("shown.bs.collapse", shown);
                let collInst = bootstrap.Collapse.getInstance(parent);
                if (collInst === null) {
                    collInst = new bootstrap.Collapse(parent, {toggle: false});
                }
                collInst.show();
                parent = parent.parentNode.closest(".collapse:not(.show)");
            }

            function scrollToVisible(targetUUID) {
                const tabContent = document.getElementById("tab-content");
                const target = tabContent.querySelector(targetUUID);
                const tabOffset = tabContent.getBoundingClientRect().top + document.body.scrollTop;
                const targetOffset = target.parentNode.getBoundingClientRect().top + document.body.scrollTop;
                tabContent.scrollTop = tabContent.scrollTop + targetOffset - tabOffset;
            };
        },

        resetAttrs() {
            if (document.getElementById("sshInput").checked === true) {
                d3.select("#app-tree").selectAll("li.attribute:not(.SSH)").classed("d-none", true);
                d3.select("#app-tree").selectAll("li.link:not(.SSH)").classed("d-none", true);
                d3.select("#app-tree").selectAll("li.attribute.SSH").classed("d-none", false);
                d3.select("#app-tree").selectAll("li.link.SSH").classed("d-none", false);
            } else {
                d3.select("#app-tree").selectAll("li.attribute:not(.SSH)").classed("d-none", false);
                d3.select("#app-tree").selectAll("li.link:not(.SSH)").classed("d-none", false)
                d3.select("#app-tree").selectAll("li.attribute.SSH").classed("d-none", true);
                d3.select("#app-tree").selectAll("li.link.SSH").classed("d-none", true);
            }
        }
    }
    </script> 
    
</cimTree>
