/*
 This tag renders a schematic diagram of a given CIM file.

 Copyright 2017-2020 Daniele Pala (pala.daniele@gmail.com)

 This file is part of CIMDraw.

 CIMDraw is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 CIMDraw is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with CIMDraw. If not, see http://www.gnu.org/licenses/.
*/

<cimDiagram>
    <style>
     .app-diagram {
         max-height: 800px;
     }

     path.domain {
         fill: none;
         stroke: black;
     }

     g.tick > line {
         stroke: black;
         stroke-dasharray: 1 5;
     }

     svg {
         width: 1200px;
         height: 800px;
     }
 
     line.highlight-x, line.highlight-y {
         stroke: red;
         stroke-width: 1;
     }

     g.resize > rect {
         stroke: black;
         stroke-width: 2;
     }
    </style>
    
    <cimDiagramControls model={props.model} dispatcher={props.dispatcher}></cimDiagramControls>
    <div class="app-diagram">   
        <svg width="1200" height="800" style="border: 1px solid black;">
            <path stroke-width="1" stroke="black" fill="none"></path>
            <circle r="3.5" cy="-10" cx="-10"></circle>
            <g id="diagram-brush"></g>
            <g id="diagram-grid"></g>
            <g id="diagram-highlight">
                <line class="highlight-x"></line>
                <line class="highlight-y"></line>
            </g>
            <g id="diagram-main">
                <g class="edges"></g>
            </g>
            <g id="diagram-legend" transform="translate(1050,50)">
                <rect id="legend-rect" x="0" y="0" width="150" height="100" fill="white"/>
                <text x="75" y="25" text-anchor="middle" font-weight="bold">Legend</text>
            </g>
        </svg>
    </div>    
    <script>
    // General defs
    const LABEL_SIZE = 3; // size of text labels associted to objects
    // Edge-related defs
    const EDGE_WIDTH = 1; // width of edges
    // AC line-related defs
    const LINE_WIDTH = 2; // width of AC lines
    // Node-related defs
    const NODE_WIDTH = 2; // width of busbars
    // Switch-related defs
    const SWITCH_HEIGHT = 10; // height of switch elements
    const SWITCH_WIDTH = 10; // width of switch elements
    // generator-related defs
    const GEN_HEIGHT = 25;  // height of generator elements
    const GEN_LINE_WIDTH = 1; //line width of generators
    // load-related defs
    const LOAD_HEIGHT = 20;  // height of load elements
    const LOAD_WIDTH = 30;  // width of load elements
    const LOAD_LINE_WIDTH = 2; // line width of loads
    // compensator-related defs
    const COMP_HEIGHT = 20;  // height of compensator elements
    const COMP_WIDTH = 30;  // width of compensator elements
    const COMP_CONN_WIDTH = 1; // line width of compensator connections
    const COMP_LINE_WIDTH = 4; // line width of compensators
    // trafo-related defs
    const TRAFO_HEIGHT = 50;  // height of transformer elements
    const TRAFO_RADIUS = 14;
    // terminal-related defs
    const TERMINAL_RADIUS = 1; // radius of terminals
    const HIGHLIGHT_RADIUS = 4; // radius of highlighted terminals
    const TERMINAL_OFFSET = 0; // distance between element and its terminals
    // color scale for voltage levels
    const colors = d3.scaleSequential([0, 500], d3.interpolateTurbo);

    let self  = null;
    let NODE_CLASS = "ConnectivityNode";
    let NODE_TERM = "ConnectivityNode.Terminals";
    let TERM_NODE = "Terminal.ConnectivityNode";
     
    export default {
        onBeforeMount(props, state) {
            self = this;
            // listen to 'showDiagram' event from parent
            self.props.dispatcher.on("showDiagram", function(file, name, element) {
                if (decodeURI(name) !== self.diagramName) {
                    let mode = self.props.model.getMode();
                    if (mode === "BUS_BRANCH") {
                        NODE_CLASS = "TopologicalNode";
                        NODE_TERM = "TopologicalNode.Terminal";
                        TERM_NODE = "Terminal.TopologicalNode";
                    }
                    self.render(name);
                }
                if (typeof(element) !== "undefined") {
                    self.moveTo(element);
                    self.props.dispatcher.trigger("moveTo", element);
                } else {
                    self.props.dispatcher.trigger("deselect");
                }
            });
            // listen to 'transform' event
            self.props.dispatcher.on("transform", function() {
                let transform = d3.zoomTransform(d3.select("svg").node());
                let newx = transform.x;
                let newy = transform.y;
                let newZoom = transform.k;
                let svgWidth = parseInt(d3.select("svg").style("width"));
                let svgHeight = parseInt(d3.select("svg").style("height"));
                // manage axes
                let xScale = d3.scaleLinear().domain([-newx/newZoom, (svgWidth-newx)/newZoom]).range([0, svgWidth]);
                let yScale = d3.scaleLinear().domain([-newy/newZoom, (svgHeight-newy)/newZoom]).range([0, svgHeight]);
                let yAxis = d3.axisRight(yScale);
                let xAxis = d3.axisBottom(xScale);
                d3.select("svg").select("#diagram-yAxis").call(yAxis);
                d3.select("svg").select("#diagram-xAxis").call(xAxis);
            });
            // listen to 'setAttribute' event from model
            self.props.model.on("setAttribute", function(object, attrName, value) {
                switch (attrName) {
                    case "cim:IdentifiedObject.name": {
                        let type = object.localName;
                        let uuid = self.props.model.ID(object);
                        // special case for busbars
                        if (object.nodeName === "cim:BusbarSection") {
                            let cn = self.props.model.getNode(object);
                            if (cn === null) {
                                return;
                            }
                            type = cn.localName;
                            uuid = self.props.model.ID(cn);
                        }
                        let types = d3.select("svg").selectAll("svg > g#diagram-main > g." + type + "s");
                        let target = types.select("#cimdiagram-" + uuid);
                        target.select("text").html(value);
                        break;
                    }
                    case "cim:AnalogValue.value": {
                        let analog = self.props.model.getTargets(
                            [object],
                            "AnalogValue.Analog");
                        let psr = self.props.model.getTargets(
                            analog,
                            "Measurement.PowerSystemResource")[0];
                        // handle busbars
                        if (psr.nodeName === "cim:BusbarSection") {
                            psr = self.props.model.getNode(psr);
                        }
                        let psrUUID = self.props.model.ID(psr);
                        let psrSelection = d3.select("g#cimdiagram-" + psrUUID);
                        self.createStatusInfo(psrSelection);
                        break;
                    }
                    case "cim:SvPowerFlow.p":
                    case "cim:SvPowerFlow.q": {
                        let svTerminal = self.props.model.getTargets(
                            [object],
                            "SvPowerFlow.Terminal")[0];
                        if (typeof(svTerminal) !== "undefined") {
                            let psr = self.props.model.getTargets(
                                [svTerminal],
                                "Terminal.ConductingEquipment")[0];
                            let psrUUID = self.props.model.ID(psr);
                            let psrSelection = d3.select("g#cimdiagram-" + psrUUID);
                            self.createStatusInfo(psrSelection);
                        }
                        break;
                    }
                    case "cim:BaseVoltage.nominalVoltage": {
                        // if a nominal voltage is changed we update the legend
                        self.drawLegend();
                        // we also update the color of the affected elements
                        // AC lines
                        const eqs = self.props.model.getTargets([object], "BaseVoltage.ConductingEquipment");
                        const aclines = eqs.filter(function(el) {
                            return self.props.model.schema.isA("ACLineSegment", el) === true;
                        });
                        self.drawACLines(aclines);
                        // Busbars
                        let nodes = eqs.filter(function(el) {
                            return self.props.model.schema.isA("BusbarSection", el) === true;
                        }).map(el => self.props.model.getNode(el));
                        self.drawNodes(nodes);
                        // Transformers - here we have a different link
                        const trafoEnds = self.props.model.getTargets([object], "BaseVoltage.TransformerEnds");
                        for (const trafoEnd of trafoEnds) {
                            const termNode = self.getTermNode(trafoEnd);
                            if (termNode !== null) {
                                self.handlePowerTransformerEnds(termNode);
                            }
                        };
                        break;
                    }
                }
                if (object.nodeName === "cim:Analog" ||
                    object.nodeName === "cim:Discrete") {
                    let psr = self.props.model.getTargets(
                        [object],
                        "Measurement.PowerSystemResource")[0];
                    if (typeof(psr) !== "undefined") {
                        // handle busbars
                        if (psr.nodeName === "cim:BusbarSection") {
                            psr = self.props.model.getNode(psr);
                        }       
                        let psrUUID = self.props.model.ID(psr);
                        let psrSelection = d3.select("g#cimdiagram-" + psrUUID);
                        self.createStatusInfo(psrSelection);
                    }
                }
                if (object.nodeName === "cim:OperationalLimitSet") {
                    let psr = self.props.model.getTargets(
                            [object],
                            "OperationalLimitSet.Equipment");
                    // limit sets may also be associated to terminals
                    let terms = self.props.model.getTargets(
                        [object],
                        "OperationalLimitSet.Terminal");
                    psr = psr.concat(self.props.model.getTargets(
                        terms,
                        "Terminal.ConductingEquipment"))[0];
                    if (typeof(psr) !== "undefined") {
                        // handle busbars
                        if (psr.nodeName === "cim:BusbarSection") {
                            psr = self.props.model.getNode(psr);
                        }       
                        let psrUUID = self.props.model.ID(psr);
                        let psrSelection = d3.select("g#cimdiagram-" + psrUUID);
                        self.createStatusInfo(psrSelection);
                    }
                }
            });
            // listen to 'setEnum' event from model
            self.props.model.on("setEnum", function(object, enumName, value) {
                if (object.nodeName === "cim:Analog" || object.nodeName === "cim:Discrete") {
                    let psr = self.props.model.getTargets(
                        [object],
                        "Measurement.PowerSystemResource")[0];
                    if (typeof(psr) !== "undefined") {
                        // handle busbars
                        if (psr.nodeName === "cim:BusbarSection") {
                            psr = self.props.model.getNode(psr);
                        }       
                        let psrUUID = self.props.model.ID(psr);
                        let psrSelection = d3.select("g#cimdiagram-" + psrUUID);
                        self.createStatusInfo(psrSelection);
                    }
                }
                switch (enumName) {
                    case "cim:PowerTransformerEnd.connectionKind": {
                        const termNode = self.getTermNode(object);
                        if (termNode !== null) {
                            self.handlePowerTransformerEnds(termNode);
                        }
                        break;
                    }
                }
            });
            // Listen to 'updateActiveDiagram' event from model.
            // This should replace the calls to 'forceTick' in other components.
            self.props.model.on("updateActiveDiagram", function(object) {
                let selection = null;
                switch (object.nodeName) {
                    case "cim:ACLineSegment":
                        selection = self.drawACLines([object])[0];
                        self.createTerminals(selection);
                        break;
                    case "cim:" + NODE_CLASS:
                        self.drawNodes([object]);
                        break;
                }
                let type = object.localName;
                let uuid = self.props.model.ID(object);
                let types = d3.select("svg").selectAll("svg > g#diagram-main > g." + type + "s");
                let target = types.select("#cimdiagram-" + uuid);
                self.forceTick(target); 
            });     
            // listen to 'addToActiveDiagram' event from model
            self.props.model.on("addToActiveDiagram", function(object) {
                let selection = null;
                switch (object.nodeName) {      
                    case "cim:ACLineSegment":
                        selection = self.drawACLines([object])[1]; // TODO: handle correctly
                        break;
                    case "cim:Breaker":
                        selection = self.drawBreakers([object]);
                        break;
                    case "cim:Disconnector":
                        selection = self.drawDisconnectors([object]);
                        break;
                    case "cim:LoadBreakSwitch":
                        selection = self.drawLoadBreakSwitches([object]);
                        break;
                    case "cim:Junction":
                        selection = self.drawJunctions([object]);
                        break;
                    case "cim:EnergySource":
                        selection = self.drawEnergySources([object]);
                        break;
                    case "cim:SynchronousMachine":
                        selection = self.drawSynchronousMachines([object]);
                        break;
                    case "cim:AsynchronousMachine":
                        selection = self.drawAsynchronousMachines([object]);
                        break;
                    case "cim:EnergyConsumer":
                        selection = self.drawEnergyConsumers([object]);
                        break;
                    case "cim:ConformLoad":
                        selection = self.drawConformLoads([object]);
                        break;
                    case "cim:NonConformLoad":
                        selection = self.drawNonConformLoads([object]);
                        break;
                    case "cim:EquivalentInjection":
                        selection = self.drawEquivalentInjections([object]);
                        break;
                    case "cim:LinearShuntCompensator":
                        selection = self.drawLinearCompensators([object]);
                        break;
                    case "cim:NonlinearShuntCompensator":
                        selection = self.drawNonlinearCompensators([object]);
                        break;          
                    case "cim:PowerTransformer":
                        selection = self.drawPowerTransformers([object]);
                        break;
                    case "cim:" + NODE_CLASS:
                        selection = self.drawNodes([object]);
                        updateEdges(object, null);
                        break;
                }
                
                if (selection !== null) {
                    handleTerminals(selection);
                }
                // handle busbars
                if (object.nodeName === "cim:BusbarSection") {
                    let terminal = self.props.model.getTargets(
                        [object],
                        "ConductingEquipment.Terminals");
                    let cn = self.props.model.getTargets(
                        terminal,
                        TERM_NODE)[0];
                    selection = self.drawNodes([cn]);
                    updateEdges(cn, object);
                }

                if (selection !== null) {
                    self.forceTick(selection);
                    self.props.dispatcher.trigger("addToDiagram", selection);
                }

                function handleTerminals(selection) {
                    let terminals = self.props.model.getTerminals([object]);
                    for (let terminal of terminals) {
                        let cn = self.props.model.getTargets(
                            [terminal],
                            TERM_NODE)[0];
                        if (typeof(cn) !== "undefined") {
                            let equipments = self.props.model.getEquipments(cn);
                            // let's try to get a busbar section
                            let busbarSection = equipments.filter(el => el.localName === "BusbarSection")[0];               
                            equipments = equipments.filter(el => el !== busbarSection);
                            if (equipments.length > 1) {
                                self.drawNodes([cn]);

                                let eqTerminals = self.props.model.getTerminals(equipments);
                                for (let eqTerminal of eqTerminals) {
                                    let eqCn = self.props.model.getTargets(
                                        [eqTerminal],
                                        TERM_NODE)[0];
                                    if (eqCn === cn) {
                                        let newEdge = {source: cn, target: eqTerminal};
                                        self.createEdges([newEdge]);
                                    }
                                }
                            }
                        }
                    }
                    self.createTerminals(selection);
                };

                function updateEdges(node, busbar) {
                    let equipments = self.props.model.getEquipments(node).filter(eq => eq !== busbar);
                    let eqTerminals = self.props.model.getTerminals(equipments);
                    for (let eqTerminal of eqTerminals) {
                        if (typeof(eqTerminal.x) === "undefined") {
                            continue;
                        }
                        let eqNode = self.props.model.getTargets(
                            [eqTerminal],
                            TERM_NODE)[0];
                        if (eqNode === node) {
                            let newEdge = {source: node, target: eqTerminal};
                            self.createEdges([newEdge]);
                        }
                    }   
                };
                
            });
            // listen to 'addLink' event from model
            // this function checks if the terminal belongs to the current diagram
            // TODO: should check also the connectivity node
            self.props.model.on("addLink", function(source, linkName, target) {
                switch (linkName) {
                    case "cim:" + TERM_NODE:
                    case "cim:" + NODE_TERM: {
                        let cn = undefined;
                        let term = undefined;
                        if (target.nodeName === "cim:Terminal" && source.nodeName === "cim:" + NODE_CLASS) {
                            cn = source;
                            term = target;
                        } else {
                            if (source.nodeName === "cim:Terminal" && target.nodeName === "cim:" + NODE_CLASS) {
                                term = source;
                                cn = target;
                            } else {
                                return;
                            }
                        }
                        let edgeToChange = d3.select("svg").selectAll("svg > g#diagram-main > g.edges > g").data().filter(el => el.target === term)[0];
                        if (typeof(edgeToChange) === "undefined") {
                            let equipment = self.props.model.getTargets(
                                [term],
                                "Terminal.ConductingEquipment");
                            let dobjs = self.props.model.getDiagramObjects(equipment);
                            if (dobjs.length > 0) {
                                edgeToChange = {source: cn, target: term};
                                self.createEdges([edgeToChange]);
                            }
                        } else {
                            edgeToChange.source = cn;
                        }
                        let cnUUID = self.props.model.ID(cn);
                        let selection = d3.select("svg > g#diagram-main > g." + NODE_CLASS + "s > g#cimdiagram-" + cnUUID);
                        self.forceTick(selection);
                        break;
                    }
                    case "cim:Terminal.SvPowerFlow":
                    case "cim:SvPowerFlow.Terminal": {
                        // power flow results
                        let terminal = target;
                        if (source.nodeName === "cim:Terminal") {
                            terminal = source;
                        }
                        if (typeof(terminal) !== "undefined") {
                            let psr = self.props.model.getTargets(
                                [terminal],
                                "Terminal.ConductingEquipment")[0];
                            let psrUUID = self.props.model.ID(psr);
                            let psrSelection = d3.select("g#cimdiagram-" + psrUUID);
                            self.createStatusInfo(psrSelection);
                        }
                        break;
                    }
                    case "cim:Measurement.Terminal":
                    case "cim:ACDCTerminal.Measurements": {
                        let terminal = target;
                        if (source.nodeName === "cim:Terminal") {
                            terminal = source;
                        }
                        let psr = self.props.model.getTargets(
                            [terminal],
                            "Terminal.ConductingEquipment")[0];
                        let measPsrUUID = self.props.model.ID(psr);
                        let measPsrSelection = d3.select("g#cimdiagram-" + measPsrUUID);
                        self.createStatusInfo(measPsrSelection);
                        break;
                    }
                    case "cim:Measurement.PowerSystemResource":
                    case "cim:PowerSystemResource.Measurements": {
                        let psr = target;
                        if (linkName === "cim:PowerSystemResource.Measurements") {
                            psr = source;
                        }
                        if (typeof(psr) !== "undefined") {
                            // handle busbars
                            if (psr.nodeName === "cim:BusbarSection") {
                                psr = self.props.model.getNode(psr);
                            }   
                            let psrUUID = self.props.model.ID(psr);
                            let psrSelection = d3.select("g#cimdiagram-" + psrUUID);
                            self.createStatusInfo(psrSelection);
                        }
                        break;
                    }
                    case "cim:OperationalLimitSet.Terminal":
                    case "cim:ACDCTerminal.OperationalLimitSet": {
                        let terminal = target;
                        if (source.nodeName === "cim:Terminal") {
                            terminal = source;
                        }
                        let psr = self.props.model.getTargets(
                            [terminal],
                            "Terminal.ConductingEquipment")[0];
                        let limPsrUUID = self.props.model.ID(psr);
                        let limPsrSelection = d3.select("g#cimdiagram-" + limPsrUUID);
                        self.createStatusInfo(limPsrSelection);
                        break;
                    }
                    case "cim:OperationalLimitSet.Equipment":
                    case "cim:Equipment.OperationalLimitSet": {
                        let psr = target;
                        if (linkName === "cim:Equipment.OperationalLimitSet") {
                            psr = source;
                        }
                        if (typeof(psr) !== "undefined") {
                            // handle busbars
                            if (psr.nodeName === "cim:BusbarSection") {
                                psr = self.props.model.getNode(psr);
                            }   
                            let psrUUID = self.props.model.ID(psr);
                            let psrSelection = d3.select("g#cimdiagram-" + psrUUID);
                            self.createStatusInfo(psrSelection);
                        }
                        break;
                    }
                    case "cim:ConductingEquipment.BaseVoltage":
                    case "cim:BaseVoltage.ConductingEquipment": 
                    case "cim:BaseVoltage.TransformerEnds":
                    case "cim:TransformerEnd.BaseVoltage": {
                        self.updateColoring(source, linkName, target);
                        break;
                    }
                }
            });
            // listen to 'removeLink' event from model
            self.props.model.on("removeLink", function(source, linkName, target) {
                switch (linkName) {
                    case "cim:Measurement.PowerSystemResource":
                    case "cim:PowerSystemResource.Measurements": {
                        let psr = target;
                        if (linkName === "cim:PowerSystemResource.Measurements") {
                            psr = source;
                        }
                        if (typeof(psr) !== "undefined") {
                            // handle busbars
                            if (psr.nodeName === "cim:BusbarSection") {
                                psr = self.props.model.getNode(psr);
                            }   
                            let psrUUID = self.props.model.ID(psr);
                            let psrSelection = d3.select("g#" + psrUUID);
                            self.createStatusInfo(psrSelection);
                        }
                        break;
                    }
                    case "cim:" + TERM_NODE:
                    case "cim:" + NODE_TERM: {
                        let cn = undefined;
                        let term = undefined;
                        if (target.nodeName === "cim:Terminal" && source.nodeName === "cim:" + NODE_CLASS) {
                            cn = source;
                            term = target;
                        } else {
                            if (source.nodeName === "cim:Terminal" && target.nodeName === "cim:" + NODE_CLASS) {
                                term = source;
                                cn = target;
                            } else {
                                return;
                            }
                        }
                        d3.select("svg")
                        .selectAll("svg > g#diagram-main > g.edges > g")
                        .filter(function(d) {
                            return d.target === term
                        })
                        .remove();
                        break;
                    }
                    case "cim:OperationalLimitSet.Terminal":
                    case "cim:ACDCTerminal.OperationalLimitSet": {
                        let terminal = target;
                        if (source.nodeName === "cim:Terminal") {
                            terminal = source;
                        }
                        let psr = self.props.model.getTargets(
                            [terminal],
                            "Terminal.ConductingEquipment")[0];
                        if (typeof(psr) !== "undefined") {
                            let limPsrUUID = self.props.model.ID(psr);
                            let limPsrSelection = d3.select("g#" + limPsrUUID);
                            self.createStatusInfo(limPsrSelection);
                        }
                        break;
                    }
                    case "cim:OperationalLimitSet.Equipment":
                    case "cim:Equipment.OperationalLimitSet": {
                        let psr = target;
                        if (linkName === "cim:Equipment.OperationalLimitSet") {
                            psr = source;
                        }
                        if (typeof(psr) !== "undefined") {
                            // handle busbars
                            if (psr.nodeName === "cim:BusbarSection") {
                                psr = self.props.model.getNode(psr);
                            }
                            if (psr !== null) {
                                let psrUUID = self.props.model.ID(psr);
                                let psrSelection = d3.select("g#" + psrUUID);
                                self.createStatusInfo(psrSelection);
                            }
                        }
                        break;
                    }
                    case "cim:ConductingEquipment.BaseVoltage":
                    case "cim:BaseVoltage.ConductingEquipment": 
                    case "cim:BaseVoltage.TransformerEnds":
                    case "cim:TransformerEnd.BaseVoltage": {
                        self.updateColoring(source, linkName, target);
                        break;
                    }
                }
            });
            // listen to 'deleteObject' event from model
            self.props.model.on("deleteObject", function(objectUUID, objectType) {
                // this must be called only for base voltages
                if (objectType === "BaseVoltage") {
                    self.drawLegend();
                }
            });
            
        },

        // listen to 'mount' event
        onMounted() {
            // setup xy axes
            let xScale = d3.scaleLinear().domain([0, 1200]).range([0,1200]);
            let yScale = d3.scaleLinear().domain([0, 800]).range([0, 800]);
            let yAxis = d3.axisRight(yScale);
            let xAxis = d3.axisBottom(xScale);
            d3.select("svg").append("g").attr("id", "diagram-yAxis").call(yAxis);
            d3.select("svg").append("g").attr("id", "diagram-xAxis").call(xAxis);
            // draw grid
            self.drawGrid(1.0);
        },
          
        render(diagramName) {
            let diagramRender = renderGenerator(diagramName);
            function periodic() {
                let ret = diagramRender.next().value;
                if (typeof(ret) !== "undefined") {
                    document.getElementById("loadingDiagramMsg").innerHTML = "<br>" + ret;
                    setTimeout(periodic, 1);
                } else {
                    self.props.dispatcher.trigger("loaded");
                }
            };
            periodic();

            function* renderGenerator(diagramName) {
                // clear all
                d3.select("svg").select("g#diagram-main").selectAll("g:not(.edges)").remove();

                self.props.model.selectDiagram(decodeURI(diagramName));
                self.diagramName = decodeURI(diagramName);
                const allNodes = self.props.model.getNodes();
                yield "DIAGRAM: extracted nodes";
                
                const allEquipments = self.props.model.getGraphicObjects(
                    ["cim:ACLineSegment",
                    "cim:Breaker",
                    "cim:Disconnector",
                    "cim:LoadBreakSwitch",
                    "cim:Junction",
                    "cim:EnergySource",
                    "cim:SynchronousMachine",
                    "cim:AsynchronousMachine",
                    "cim:EnergyConsumer",
                    "cim:ConformLoad",
                    "cim:NonConformLoad",
                    "cim:EquivalentInjection",
                    "cim:PowerTransformer",
                    "cim:BusbarSection",
                    "cim:LinearShuntCompensator",
                    "cim:NonlinearShuntCompensator"]);
                const allACLines = allEquipments["cim:ACLineSegment"];
                const allBreakers = allEquipments["cim:Breaker"];
                const allDisconnectors = allEquipments["cim:Disconnector"]; 
                const allLoadBreakSwitches = allEquipments["cim:LoadBreakSwitch"]; 
                const allJunctions = allEquipments["cim:Junction"];
                const allEnergySources = allEquipments["cim:EnergySource"];
                const allSynchronousMachines = allEquipments["cim:SynchronousMachine"];
                const allAsynchronousMachines = allEquipments["cim:AsynchronousMachine"];
                const allEnergyConsumers = allEquipments["cim:EnergyConsumer"];
                const allConformLoads = allEquipments["cim:ConformLoad"];
                const allNonConformLoads = allEquipments["cim:NonConformLoad"];
                const allEquivalentInjections = allEquipments["cim:EquivalentInjection"];
                const allPowerTransformers = allEquipments["cim:PowerTransformer"];
                const allBusbarSections = allEquipments["cim:BusbarSection"];
                const allLinearShuntCompensators = allEquipments["cim:LinearShuntCompensator"];
                const allNonlinearShuntCompensators = allEquipments["cim:NonlinearShuntCompensator"];
                yield "DIAGRAM: extracted equipments";
                
                // AC Lines
                const aclineEnter = self.drawACLines(allACLines)[1];
                yield "DIAGRAM: drawn acLines";
                // breakers
                const breakerEnter = self.drawBreakers(allBreakers);
                yield "DIAGRAM: drawn breakers";
                // disconnectors
                const discEnter = self.drawDisconnectors(allDisconnectors);
                yield "DIAGRAM: drawn disconnectors";
                // load break switches
                const lbsEnter = self.drawLoadBreakSwitches(allLoadBreakSwitches);
                yield "DIAGRAM: drawn load break switches";
                // junctions
                const junctsEnter = self.drawJunctions(allJunctions);
                yield "DIAGRAM: drawn junctions";
                // energy sources
                const ensrcEnter = self.drawEnergySources(allEnergySources);
                yield "DIAGRAM: drawn energy sources";
                // synchronous machines
                const syncEnter = self.drawSynchronousMachines(allSynchronousMachines);
                yield "DIAGRAM: drawn synchronous machines";
                // asynchronous machines
                const asyncEnter = self.drawAsynchronousMachines(allAsynchronousMachines);
                yield "DIAGRAM: drawn asynchronous machines";      
                // energy consumers
                const enconsEnter = self.drawEnergyConsumers(allEnergyConsumers);
                yield "DIAGRAM: drawn energy consumers";
                // conform loads
                const confEnter = self.drawConformLoads(allConformLoads);
                yield "DIAGRAM: drawn conform loads";
                // non conform loads
                const nonconfEnter = self.drawNonConformLoads(allNonConformLoads);
                yield "DIAGRAM: drawn non conform loads";
                // equivalent injections
                const eqInjEnter = self.drawEquivalentInjections(allEquivalentInjections);
                yield "DIAGRAM: drawn equivalent injections";
                // power transformers
                const trafoEnter = self.drawPowerTransformers(allPowerTransformers);
                yield "DIAGRAM: drawn power transformers";
                // linear shunt compensators
                const lshuntEnter = self.drawLinearCompensators(allLinearShuntCompensators);
                yield "DIAGRAM: drawn linear shunt compensators";
                // nonlinear shunt compensators
                const nlshuntEnter = self.drawNonlinearCompensators(allNonlinearShuntCompensators);
                yield "DIAGRAM: drawn nonlinear shunt compensators";
                // connectivity nodes
                const cnEnter = self.drawNodes(allNodes);
                self.createStatusInfo(cnEnter);
                yield "DIAGRAM: drawn connectivity nodes";

                // ac line terminals
                self.createTerminals(aclineEnter);
                self.createStatusInfo(aclineEnter);
                yield "DIAGRAM: drawn acline terminals";
                // breaker terminals
                self.createTerminals(breakerEnter);
                self.createStatusInfo(breakerEnter);
                yield "DIAGRAM: drawn breaker terminals";
                // disconnector terminals
                self.createTerminals(discEnter);
                self.createStatusInfo(discEnter);
                yield "DIAGRAM: drawn disconnector terminals";
                // load break switch terminals
                self.createTerminals(lbsEnter);
                self.createStatusInfo(lbsEnter);
                yield "DIAGRAM: drawn load break switch terminals";
                // junction terminals
                self.createTerminals(junctsEnter);
                self.createStatusInfo(junctsEnter);
                yield "DIAGRAM: drawn junction terminals";
                // energy source terminals
                self.createTerminals(ensrcEnter);
                self.createStatusInfo(ensrcEnter);
                yield "DIAGRAM: drawn energy source terminals";
                // synchronous machine terminals
                self.createTerminals(syncEnter);
                self.createStatusInfo(syncEnter);
                yield "DIAGRAM: drawn synchronous machine terminals";
                // asynchronous machine terminals
                self.createTerminals(asyncEnter);
                self.createStatusInfo(asyncEnter);
                yield "DIAGRAM: drawn asynchronous machine terminals";
                // energy consumer terminals
                self.createTerminals(enconsEnter);
                self.createStatusInfo(enconsEnter);
                yield "DIAGRAM: drawn energy consumer terminals";
                // conform load terminals
                self.createTerminals(confEnter);
                self.createStatusInfo(confEnter);
                yield "DIAGRAM: drawn conform load terminals";
                // non conform load terminals
                self.createTerminals(nonconfEnter);
                self.createStatusInfo(nonconfEnter);
                yield "DIAGRAM: drawn non conform load terminals";
                // equivalent injection terminals
                self.createTerminals(eqInjEnter);
                self.createStatusInfo(eqInjEnter);
                yield "DIAGRAM: drawn equivalent injection terminals";
                // power transformer terminals
                self.createTerminals(trafoEnter);
                self.createStatusInfo(trafoEnter);
                yield "DIAGRAM: drawn power transformer terminals";
                // linear shunt compensator terminals
                self.createTerminals(lshuntEnter);
                self.createStatusInfo(lshuntEnter);
                yield "DIAGRAM: drawn linear shunt compensator terminals";
                // nonlinear shunt compensator terminals
                self.createTerminals(nlshuntEnter);
                self.createStatusInfo(nlshuntEnter);
                yield "DIAGRAM: drawn nonlinear shunt compensator terminals";
                
                // draw the legend
                self.drawLegend();
                
                d3.select("svg").on("dragover", function(event) {
                    event.preventDefault();
                }).on("drop", function(event) {
                    event.preventDefault();
                    const objUUID = event.dataTransfer.getData("text/plain");
                    if (typeof(objUUID) === "undefined") {
                        return;
                    }
                    const datum = self.props.model.getObject(objUUID);
                    if (typeof(datum) === "undefined") {
                        return;
                    }
                    const dobjs = self.props.model.getDiagramObjects([datum]);
                    if (dobjs.length > 0) {
                        self.moveTo(objUUID);
                    } else {
                        // add object to diagram
                        addToDiagram(self.props.model, event, datum);
                    }
                });

                function mouseOut(d) {
                    d3.select(this).selectAll("rect").remove();             
                }
                
                self.forceTick();
                self.props.dispatcher.trigger("render");
            };
        },

        createEdges(edges) {
            let edgesEnter = d3
                .select("svg")
                .select("g > g.edges")
                .selectAll("g.edge")
                .data(edges, function(d) {
                    return d.source.attributes[0].value+d.target.attributes[0].value;
                })
                .enter()
                .append("g")
                .attr("class", "edge")
                .attr("id", function(d) {
                    return d.source.attributes[0].value+d.target.attributes[0].value;
                })
                .append("path")
                .attr("fill", "none")
                .attr("stroke", "black")
                .attr("stroke-width", EDGE_WIDTH);
            self.props.dispatcher.trigger("createEdges", edgesEnter);
        },

        // Create element status info (measurements, state variables, operational
        // limits) associated with a selection of terminals or power system resources.
        // This is visualized as a popover.
        // TODO: junctions
        createStatusInfo(psrSelection) {
            psrSelection.attr("data-toggle", "popover");
            // change fill color of switches based on their status
            let path = psrSelection.filter(function(d) {
                return self.props.model.schema.isA("Switch", d);
            }).selectAll("path");
            path.attr("fill", function(d) {
                // check the status of this switch
                let measurement = self.props.model.getTargets(
                    [d],
                    "PowerSystemResource.Measurements")[0];
                let value = self.getDiscreteValue(measurement);
                if (value === "0") {
                    return "white";
                } else {
                    return "black";
                }
            });
            psrSelection.each(function(d) {
                let measurements = [];
                let svPFs = [];
                let limitSets = [];
                // get the voltage state variables for this equipment
                let svVs = self.props.model.getTargets([d], "TopologicalNode.SvVoltage");
                let terminals = self.props.model.getTerminals([d]);
                // get the measurements and limit sets for this equipment
                if (d.nodeName === "cim:" + NODE_CLASS) {           
                    let busbar = self.props.model.getBusbar(d);
                    if (busbar === null) {
                        return;
                    }
                    terminals = self.props.model.getTerminals([busbar]);
                    measurements = self.props.model.getTargets(
                        [busbar],
                        "PowerSystemResource.Measurements");
                    limitSets = self.props.model.getTargets(
                        [busbar],
                        "Equipment.OperationalLimitSet");
                } else {
                    measurements = self.props.model.getTargets(
                        [d],
                        "PowerSystemResource.Measurements");
                    limitSets = self.props.model.getTargets(
                        [d],
                        "Equipment.OperationalLimitSet");
                }
                // limit sets may also be associated to terminals
                limitSets = limitSets.concat(self.props.model.getTargets(
                    terminals,
                    "ACDCTerminal.OperationalLimitSet"));
                // get the PF state variables for this equipment
                for (let terminal of terminals) {
                    let actTermSvPFs = self.props.model.getTargets(
                        [terminal],
                        "Terminal.SvPowerFlow");
                    svPFs = svPFs.concat(actTermSvPFs);
                }
                if (measurements.length > 0 || svPFs.length > 0 || svVs.length > 0 || limitSets.length > 0) {
                    let tooltip = self.createTooltip(measurements, svPFs, svVs, limitSets);
                    // create the actual popover
                    $(this).popover("dispose").popover({title: "<b>Element Status Info</b>",
                                    content: tooltip,
                                    container: "body",
                                    html: true,
                                    trigger: "manual",
                                    delay: {"show": 200, "hide": 0},
                                    placement: "auto"
                    });
                } else {
                    // no measurements, destroy popover
                    d3.select(this).attr("data-toggle", null);
                    $(this).popover("dispose");
                }
            })
        },

        // Get the discrete value associated to a measurement, if available.
        // Defaults to OPEN.
        getDiscreteValue(measurement) {
            let value = "0"; // default is OPEN
            if (typeof(measurement) !== "undefined") {
                let valueObject = self.props.model.getTargets(
                    [measurement],
                    "Discrete.DiscreteValues")[0];
                if (typeof(valueObject) !== "undefined") {
                    let valueAttribute = self.props.model.getAttribute(valueObject, "cim:DiscreteValue.value"); 
                    if(typeof(valueAttribute) !== "undefined") {
                        value = valueAttribute.textContent;
                    }
                }
            }
            return value;
        },

        // create the actual tooltip content for element status info
        createTooltip(measurements, svPFs, svVs, limitSets) {
            let tooltip = "";
            if (measurements.length > 0) {
                tooltip = tooltip + "<b>Measurements</b><br><br>";
                let tooltipLines = [];
                for (let measurement of measurements) {
                    let type = "unnamed";
                    let phases = "ABC";
                    let unitMultiplier = "";
                    let unitSymbol = "no unit";
                    let typeAttr = self.props.model.getAttribute(measurement, "cim:IdentifiedObject.name");
                    let phasesAttr = self.props.model.getEnum(measurement, "cim:Measurement.phases");
                    let unitMultiplierAttr = self.props.model.getEnum(measurement, "cim:Measurement.unitMultiplier");
                    let unitSymbolAttr = self.props.model.getEnum(measurement, "cim:Measurement.unitSymbol");
                    if (typeof(typeAttr) !== "undefined") {
                        type = typeAttr.textContent;
                    }
                    if (typeof(phasesAttr) !== "undefined") {
                        phases = phasesAttr;
                    }
                    if (typeof(unitMultiplierAttr) !== "undefined") {
                        unitMultiplier = unitMultiplierAttr;
                        if (unitMultiplier === "none") {
                            unitMultiplier = "";
                        }
                    }
                    if (typeof(unitSymbolAttr) !== "undefined") {
                        unitSymbol = unitSymbolAttr;
                    }
                    let valueObject = self.props.model.getTargets(
                        [measurement],
                        "Analog.AnalogValues")[0];
                    let actLine = "";
                    let value = "n.a."
                    if (typeof(valueObject) !== "undefined") {
                        if(typeof(self.props.model.getAttribute(valueObject, "cim:AnalogValue.value")) !== "undefined") {
                            value = self.props.model.getAttribute(valueObject, "cim:AnalogValue.value").textContent;
                            value = parseFloat(value).toFixed(2);
                        }
                    } else {
                        value = self.getDiscreteValue(measurement);
                        value = parseInt(value);
                    }
                    let measUUID = self.props.model.ID(measurement);
                    let hashComponents = window.location.hash.split("/");
                    let basePath = hashComponents[0] + "/" + hashComponents[1] + "/" + hashComponents[2];
                    let targetPath = basePath + "/" + measUUID;
                    actLine = actLine + "<a href=" + targetPath + ">" + type + "</a>";
                    actLine = actLine + " (phase: " + phases + ")";
                    actLine = actLine + ": ";
                    actLine = actLine + value;
                    actLine = actLine + " [" + unitMultiplier + unitSymbol + "]";
                    actLine = actLine + "<br>";
                    tooltipLines.push(actLine);   
                }
                tooltipLines.sort();
                for (let i in tooltipLines) {
                    tooltip = tooltip + tooltipLines[i];
                }
            }

            // power flow results
            if (svPFs.length > 0) {
                if (tooltip !== "") {
                    tooltip = tooltip + "<br>";
                }
                tooltip = tooltip + "<b>Power flow results (Power)</b><br><br>";
                for (let sv of svPFs) {
                    let p = 0.0, q = 0.0;
                    if (typeof(self.props.model.getAttribute(sv, "cim:SvPowerFlow.p")) !== "undefined") { 
                        p = self.props.model.getAttribute(sv, "cim:SvPowerFlow.p").textContent;
                    }
                    if (typeof(self.props.model.getAttribute(sv, "cim:SvPowerFlow.q")) !== "undefined") {
                        q = self.props.model.getAttribute(sv, "cim:SvPowerFlow.q").textContent;
                    }
                    let actLine = "Active Power: " + parseFloat(p).toFixed(2) + " [MW]";
                    actLine = actLine + "<br>";
                    actLine = actLine + "Reactive power: " + parseFloat(q).toFixed(2) + " [MVAr]";
                    actLine = actLine + "<br>";
                    tooltip = tooltip + actLine;
                }   
            }

            if (svVs.length > 0) {
                if (tooltip !== "") {
                    tooltip = tooltip + "<br>";
                }
                tooltip = tooltip + "<b>Power flow results (Voltage)</b><br><br>";
                for (let sv of svVs) {
                    let v = 0.0, ang = 0.0;
                    if (typeof(self.props.model.getAttribute(sv, "cim:SvVoltage.v")) !== "undefined") {
                        v = self.props.model.getAttribute(sv, "cim:SvVoltage.v").textContent;
                    }
                    if (typeof(self.props.model.getAttribute(sv, "cim:SvVoltage.angle")) !== "undefined") {
                        ang = self.props.model.getAttribute(sv, "cim:SvVoltage.angle").textContent;
                    }
                    let actLine = "Voltage magnitude: " + parseFloat(v).toFixed(2) + " [kV]";
                    actLine = actLine + "<br>";
                    actLine = actLine + "Voltage angle: " + parseFloat(ang).toFixed(2) + " [deg]";
                    actLine = actLine + "<br>";
                    tooltip = tooltip + actLine;
                }
            }

            if (limitSets.length > 0) {
                if (tooltip !== "") {
                    tooltip = tooltip + "<br>";
                }
                tooltip = tooltip + "<b>Operational limit sets</b><br><br>";
                for (let limitSet of limitSets) {
                    let type = "unnamed";
                    let typeAttr = self.props.model.getAttribute(limitSet, "cim:IdentifiedObject.name");
                    if (typeof(typeAttr) !== "undefined") {
                        type = typeAttr.textContent;
                    }
                    let uuid = self.props.model.ID(limitSet);
                    let hashComponents = window.location.hash.split("/");
                    let basePath = hashComponents[0] + "/" + hashComponents[1] + "/" + hashComponents[2];
                    let targetPath = basePath + "/" + uuid;
                    let actLine = "<a href=" + targetPath + ">" + type + "</a><br>";
                    tooltip = tooltip + actLine;
                }
            }
            return tooltip;
        },

        // bind data to an x,y array from Diagram Object Points
        // returns a 2 element array: the first is the update selection
        // and the second is the enter selection.
        // The first argument is the CIM type, like "ACLineSegment", the
        // second is the data array.
        createSelection(type, data) {
            let types = type + "s";
            if (d3.select("svg").select("g." + types).empty()) {
                d3.select("svg").select("g#diagram-main").append("g")
                .attr("class", types);
            }

            for (let d of data) {
                calcLineData(self.props.model, d);
            }
            
            let updateSel = d3.select("svg").select("g." + types).selectAll("g." + type)
                            .data(data, function(d) {
                                return self.props.model.ID(d);
                            });
            let enterSel = updateSel
                .enter()
                .append("g")
                .attr("class", type)
                .attr("id", function(d) {
                    return "cimdiagram-" + self.props.model.ID(d);
                });
            return [updateSel, enterSel]; 
        },

        // Draw all ACLineSegments
        drawACLines(allACLines) {
            const line = d3.line()
                        .x(function(d) { return d.x; })
                            .y(function(d) { return d.y; });
            const aclineSel = self.createSelection("ACLineSegment", allACLines);
            const aclineUpdate = aclineSel[0];
            const aclineEnter = aclineSel[1];
            
            aclineEnter.append("path")
                        .attr("d", function(d) {
                            if (d.lineData.length === 1) {
                                d.lineData.push({x:150, y:0, seq:2});
                            }
                            return line(d.lineData);
                        })
                        .attr("fill", "none")
                        .attr("stroke", function(d) {
                            return self.voltageColor(d, "darkred");
                        })
                        .attr("stroke-width", LINE_WIDTH);
            aclineEnter.append("text")
                        .attr("class", "cim-object-text")
                        .attr("font-size", LABEL_SIZE);
            updateText(aclineUpdate.select("text"));
            updateText(aclineEnter.select("text"));
            aclineUpdate
                .select("path")
                .attr("d", function(d) {
                    if (d.lineData.length === 1) {
                        d.lineData.push({x:150, y:0, seq:2});
                    }
                    return line(d.lineData);
                })
                .attr("fill", "none")
                .attr("stroke", function(d) {
                    return self.voltageColor(d, "darkred");
                })
                .attr("stroke-width", 2);

            function updateText(selection) {
                selection.attr("x", function(d) {
                    let path = d3.select(this.parentNode).select("path").node();
                    return path.getPointAtLength(path.getTotalLength()/2).x + 2;
                }).attr("y", function(d) {
                    let path = d3.select(this.parentNode).select("path").node();
                    return path.getPointAtLength(path.getTotalLength()/2).y - 2;
                }).text(function(d) {
                    let name = self.props.model.getAttribute(d, "cim:IdentifiedObject.name");
                    if (typeof(name) !== "undefined") {
                        return name.innerHTML;
                    }
                    return "";
                });
            };
                        
            return [aclineUpdate, aclineEnter];
        },

        // Draw all Breakers
        drawBreakers(allBreakers) {
            return self.drawSwitches(allBreakers, "Breaker", "green");
        },

        // Draw all Disconnectors
        drawDisconnectors(allDisconnectors) {
            return self.drawSwitches(allDisconnectors, "Disconnector", "blue");
        },

        // Draw all load break switches
        drawLoadBreakSwitches(allLoadBreakSwitches) {
            return self.drawSwitches(allLoadBreakSwitches, "LoadBreakSwitch", "black");
        },

        // Draw all junctions
        drawJunctions(allJunctions) {
            return self.drawSwitches(allJunctions, "Junction", "red");
        },

        drawSwitches(allSwitches, type, color) {
            let line = d3.line()
                        .x(function(d) { return d.x; })
                        .y(function(d) { return d.y; })
                        .curve(d3.curveLinearClosed);
            
            let swEnter = self.createSelection(type, allSwitches)[1];
            let xStart = (SWITCH_WIDTH/2) * (-1);
            let xEnd = (SWITCH_WIDTH/2);
            let yStart = (SWITCH_HEIGHT/2)* (-1);
            let yEnd = (SWITCH_HEIGHT/2);
            
            swEnter.append("path")
                    .attr("d", function(d) {
                        return line([{x:xStart, y:yStart, seq:1},
                                    {x:xEnd, y:yStart, seq:2},
                                    {x:xEnd, y:yEnd, seq:3},
                                    {x:xStart, y:yEnd, seq:4}]);               
                    })
                    .attr("fill", function(d) {
                        // check the status of this switch
                        let measurement = self.props.model.getTargets(
                            [d],
                            "PowerSystemResource.Measurements")[0];
                        let value = self.getDiscreteValue(measurement);
                        if (value === "0") {
                            return "white";
                        } else {
                            return "black";
                        }
                    })
                    .attr("stroke", color)
                    .attr("stroke-width", 1);
            swEnter.append("text")
                    .attr("class", "cim-object-text")
                    .style("text-anchor", "end")
                    .attr("font-size", LABEL_SIZE)
                    .attr("x", -10)
                    .attr("y", 0)
                    .text(function(d) {
                        let name = self.props.model.getAttribute(d, "cim:IdentifiedObject.name");
                        if (typeof(name) !== "undefined") {
                            return name.innerHTML;
                        }
                        return "";
                    });
            return swEnter;
        },    

        // Draw all EnergySources
        drawEnergySources(allEnergySources) {
            return self.drawGenerators(allEnergySources, "EnergySource");
        },

        // Draw all SynchronousMachines
        drawSynchronousMachines(allSynchronousMachines) {
            return self.drawGenerators(allSynchronousMachines, "SynchronousMachine");
        },

        // Draw all AsynchronousMachines
        drawAsynchronousMachines(allAsynchronousMachines) {
            return self.drawGenerators(allAsynchronousMachines, "AsynchronousMachine");
        },
     
        // Draw all EnergyConsumers
        drawEnergyConsumers(allEnergyConsumers) {
            return self.drawLoads(allEnergyConsumers, "EnergyConsumer");
        },

        // Draw all ConformLoads
        drawConformLoads(allConformLoads) {
            return self.drawLoads(allConformLoads, "ConformLoad");
        },

        // Draw all NonConformLoads
        drawNonConformLoads(allNonConformLoads) {
            return self.drawLoads(allNonConformLoads, "NonConformLoad");
        },

        // Draw all EquivalentInjections
        drawEquivalentInjections(allEquivalentInjections) {
            return self.drawLoads(allEquivalentInjections, "EquivalentInjection");
        },

        // Draw all LinearShuntCompensators
        drawLinearCompensators(allLinearShuntCompensators) {
            return self.drawCompensators(allLinearShuntCompensators, "LinearShuntCompensator");
        },

        // Draw all NonlinearShuntCompensators
        drawNonlinearCompensators(allNonlinearShuntCompensators) {
            return self.drawCompensators(allNonlinearShuntCompensators, "NonlinearShuntCompensator");
        },

        // Draw all generators
        drawGenerators(allGens, type) {
            let genEnter = self.createSelection(type, allGens)[1];
            let label = "G";
            const labelSize = Math.round(GEN_HEIGHT * 0.6);
            const labelPos = (GEN_HEIGHT/4);
            if (type === "AsynchronousMachine") {
                label = "M";
            }
            
            genEnter.append("circle")
                    .attr("r", GEN_HEIGHT/2)
                    .attr("cx", 0) 
                    .attr("cy", 0)
                    .attr("fill", "white")
                    .attr("stroke", "black")
                    .attr("stroke-width", GEN_LINE_WIDTH);
            genEnter.append("text")
                    .attr("class", "cim-object-text")
                    .style("text-anchor", "middle")
                    .attr("font-size", LABEL_SIZE)
                    .attr("x", (GEN_HEIGHT/2)*1.4)
                    .attr("y", 0)
                    .text(function(d) {
                        let name = self.props.model.getAttribute(d, "cim:IdentifiedObject.name");
                        if (typeof(name) !== "undefined") {
                            return name.innerHTML;
                        }
                        return "";
                    });
            genEnter.append("text")
                    .style("text-anchor", "middle")
                    .attr("font-size", labelSize)
                    .attr("x", 0)
                    .attr("y", labelPos)
                    .text(label);
            return genEnter;
        },

        // Draw all loads
        drawLoads(allLoads, type) {
            let line = d3.line()
                        .x(function(d) { return d.x; })
                        .y(function(d) { return d.y; })
                        .curve(d3.curveLinearClosed);
            let loadEnter = self.createSelection(type, allLoads)[1];
            let lx1 = (LOAD_WIDTH/2) * (-1);
            let lx2 = (LOAD_WIDTH/2);
            let ly1 = (LOAD_HEIGHT/2) * (-1);
            let ly2 = (LOAD_HEIGHT/2);

            loadEnter.append("path")
                    .attr("d", function(d) {
                        return line([
                            {x: lx1, y:ly1, seq:1},
                            {x: lx2, y:ly1, seq:2},
                            {x: (lx2+lx1)/2, y:ly2, seq:3}]);
                    })
                    .attr("fill", "white")
                    .attr("stroke", "black")
                    .attr("stroke-width", LOAD_LINE_WIDTH);
            loadEnter.append("text")
                    .attr("class", "cim-object-text")
                    .style("text-anchor", "middle")
                    .attr("font-size", LABEL_SIZE)
                    .attr("x", 0) 
                    .attr("y", ly2 + 10)
                    .text(function(d) {
                        let name = self.props.model.getAttribute(d, "cim:IdentifiedObject.name");
                        if (typeof(name) !== "undefined") {
                            return name.innerHTML;
                            }
                        return "";
                    });
            return loadEnter;
        },

        // Draw all compensators
        drawCompensators(allCompensators, type) {
            let line = d3.line()
                        .x(function(d) { return d.x; })
                        .y(function(d) { return d.y; });
            let compEnter = self.createSelection(type, allCompensators)[1];
            let cx1 = (COMP_WIDTH/2) * (-1);
            let cx2 = (COMP_WIDTH/2);
            let cy1 = (COMP_HEIGHT/2) * (-1) * 0.4;
            let cy2 = (COMP_HEIGHT/2) * 0.4;
            let ty1 = (TERMINAL_OFFSET + (COMP_HEIGHT/2)) * (-1);
            let ty2 = (TERMINAL_OFFSET + (COMP_HEIGHT/2));

            compEnter.append("path")
                    .attr("d", function(d) {
                        return line([
                            {x: 0, y: ty1, seq:1},
                            {x: 0, y: cy1, seq:2}]);
                    })
                    .attr("fill", "white")
                    .attr("stroke", "black")
                    .attr("stroke-width", COMP_CONN_WIDTH);
            compEnter.append("path")
                    .attr("d", function(d) {
                        return line([
                            {x: 0, y: cy2, seq:1},
                            {x: 0, y: ty2, seq:2}]);
                    })
                    .attr("fill", "white")
                    .attr("stroke", "black")
                    .attr("stroke-width", COMP_CONN_WIDTH);
            compEnter.append("path")
                    .attr("d", function(d) {
                        return line([
                            {x: cx1, y: cy1, seq:1},
                            {x: cx2, y: cy1, seq:2}]);
                    })
                    .attr("fill", "white")
                    .attr("stroke", "black")
                    .attr("stroke-width", COMP_LINE_WIDTH);
            compEnter.append("path")
                    .attr("d", function(d) {
                        return line([
                            {x: cx1, y: cy2, seq:1},
                            {x: cx2, y: cy2, seq:2}]);
                    })
                    .attr("fill", "white")
                    .attr("stroke", "black")
                    .attr("stroke-width", COMP_LINE_WIDTH);
            compEnter.append("text")
                    .attr("class", "cim-object-text")
                    .style("text-anchor", "middle")
                    .attr("font-size", LABEL_SIZE)
                    .attr("x", 0) 
                    .attr("y", ty2 + 10)
                    .text(function(d) {
                        let name = self.props.model.getAttribute(d, "cim:IdentifiedObject.name");
                        if (typeof(name) !== "undefined") {
                            return name.innerHTML;
                            }
                        return "";
                    });
            return compEnter;
        },
     
        // Draw all PowerTransformers
        drawPowerTransformers(allPowerTransformers) {
            const trafoEnter = this.createSelection("PowerTransformer", allPowerTransformers)[1];
            const wind1y = TRAFO_RADIUS - (TRAFO_HEIGHT/2);
            const wind2y = (TRAFO_HEIGHT/2) - TRAFO_RADIUS;
            const wind23x = wind1y;
            const wind33x = wind2y;
            const wind13y = wind1y;
            const wind23y = wind2y;

            const twoWind = trafoEnter.filter(function(d) {
                const winds = self.props.model.getTargets([d], "PowerTransformer.PowerTransformerEnd");
                return winds.length === 2;
            });
            const threeWind = trafoEnter.filter(function(d) {
                const winds = self.props.model.getTargets([d], "PowerTransformer.PowerTransformerEnd");
                return winds.length === 3;
            });

            twoWind.append("circle")
                    .attr("r", TRAFO_RADIUS)
                    .attr("cx", 0)
                    .attr("cy", wind2y)
                    .attr("fill", "white")
                    .attr("stroke", "black")
                    .attr("stroke-width", 1);
            threeWind.append("circle")
                    .attr("r", TRAFO_RADIUS)
                    .attr("cx", wind23x) 
                    .attr("cy", wind23y)
                    .attr("fill", "white")
                    .attr("stroke", "black")
                    .attr("stroke-width", 1);
            threeWind.append("circle")
                    .attr("r", TRAFO_RADIUS)
                    .attr("cx", wind33x)
                    .attr("cy", wind23y)
                    .attr("fill", "white")
                    .attr("stroke", "black")
                    .attr("stroke-width", 1);
            
            twoWind.append("g")
                    .attr("class", "TransformerEnd")
                    .attr("transform", d3.zoomIdentity.translate(0, wind1y))
                    .append("circle")
                    .attr("r", TRAFO_RADIUS)
                    .attr("cx", 0) 
                    .attr("cy", 0)
                    .attr("fill", "white")
                    .attr("stroke", "black")
                    .attr("stroke-width", 1)
                    .attr("class", "TransformerEndCircle");
            twoWind.append("g")
                    .attr("class", "TransformerEnd")
                    .attr("transform", d3.zoomIdentity.translate(0, wind2y))
                    .append("circle")
                    .attr("r", TRAFO_RADIUS)
                    .attr("cx", 0)
                    .attr("cy", 0)
                    .attr("fill", "white")
                    .attr("fill-opacity", "0")
                    .attr("stroke", "black")
                    .attr("stroke-width", 1)
                    .attr("class", "TransformerEndCircle");
            threeWind.append("g")
                    .attr("class", "TransformerEnd")
                    .attr("transform", d3.zoomIdentity.translate(0, wind13y))
                    .append("circle")
                    .attr("r", TRAFO_RADIUS)
                    .attr("cx", 0) 
                    .attr("cy", 0)
                    .attr("fill", "white")
                    .attr("stroke", "black")
                    .attr("stroke-width", 1)
                    .attr("class", "TransformerEndCircle");
            threeWind.append("g")
                    .attr("class", "TransformerEnd")
                    .attr("transform", d3.zoomIdentity.translate(wind23x, wind23y))
                    .append("circle")
                    .attr("r", TRAFO_RADIUS)
                    .attr("cx", 0) 
                    .attr("cy", 0)
                    .attr("fill", "white")
                    .attr("fill-opacity", "0")
                    .attr("stroke", "black")
                    .attr("stroke-width", 1)
                    .attr("class", "TransformerEndCircle");
            threeWind.append("g")
                    .attr("class", "TransformerEnd")
                    .attr("transform", d3.zoomIdentity.translate(wind33x, wind23y))
                    .append("circle")
                    .attr("r", TRAFO_RADIUS)
                    .attr("cx", 0)
                    .attr("cy", 0)
                    .attr("fill", "white")
                    .attr("fill-opacity", "0")
                    .attr("stroke", "black")
                    .attr("stroke-width", 1)
                    .attr("class", "TransformerEndCircle");
            
            trafoEnter.append("text")
                    .attr("class", "cim-object-text")
                    .style("text-anchor", "end")
                    .attr("font-size", LABEL_SIZE)
                    .attr("x", (TRAFO_HEIGHT/2) * (-1))
                    .attr("y", 0)
                    .text(function(d) {
                        const name = self.props.model.getAttribute(d, "cim:IdentifiedObject.name");
                        if (typeof(name) !== "undefined") {
                            return name.innerHTML;
                        }
                        return "";
                    });
            
            return trafoEnter;
        },

        handlePowerTransformerEnds(termNode) {
            const term = d3.select(termNode).datum();
            const eq = d3.select(termNode.parentNode).datum();
            const trafoEnd = self.props.model.getTargets([term], "Terminal.TransformerEnd");
            const termX = term.x - eq.x;
            const termY = term.y - eq.y;
            let minDist2 = null;
            let circleSel = null;

            d3.select(termNode.parentNode).selectAll(":scope > g.TransformerEnd").each(function() {
                const transform = this.transform.baseVal.consolidate();
                let matrix = {e: 0, f: 0};
                if (transform !== null) { 
                    matrix = transform.matrix;
                }
                const cx = matrix.e;
                const cy = matrix.f;
                const dist2 = ((cx-termX)**2) + ((cy-termY)**2);
                if (minDist2 === null || minDist2 > dist2) {
                    minDist2 = dist2;
                    circleSel = d3.select(this);
                }
            });
            circleSel.data(trafoEnd);
            circleSel.attr("id", function() {
                return "cimdiagram-" + self.props.model.ID(trafoEnd[0]);
            });
            circleSel.select("circle.TransformerEndCircle").attr("stroke", function(d) {
                return self.voltageColor(d, "black");
            });
            circleSel.selectAll("path").remove();
            // We draw a "star" or "delta" depending on the winding connections.
            const connKind = self.props.model.getEnum(trafoEnd[0], "cim:PowerTransformerEnd.connectionKind");
            if (typeof(connKind) !== "undefined") {
                const yo = 0.2;
                const ya = 0.4;
                const o = [0, termY * yo];
                const a = [0, termY * ya];
                const len = ya - yo;
                const xlen = len * Math.sqrt(3) / 2;
                const ylen = len / 2;
                const b = [termY * (-xlen), termY * (yo - ylen)];
                const c = [termY * xlen, termY * (yo - ylen)];
                if (connKind.startsWith("Y")) {
                    circleSel.append("path")
                            .attr("d", d3.line()([a, o]))
                            .attr("stroke", "black");
                    circleSel.append("path")
                            .attr("d", d3.line()([o, b]))
                            .attr("stroke", "black");
                    circleSel.append("path")
                            .attr("d", d3.line()([o, c]))
                            .attr("stroke", "black");
                }
                if (connKind === "D") {
                    circleSel.append("path")
                            .attr("d", d3.line().curve(d3.curveLinearClosed)([a, b, c]))
                            .attr("stroke", "black")
                            .attr("fill", "white");
                }
            }
        },

        // Adds terminals to the objects contained in the selection.
        // The elements must all be of the same type (e.g. switches, loads...).
        // This function is quite complicated because we want to draw terminals
        // in the "correct" place, i.e. as close as possible to the
        // associated bus.
        createTerminals(eqSelection) {
            let term1_cy = 0; // default y coordinate for first terminal
            let term2_cy = 30; // default y coordinate for second terminal (if present)
            let objType = "none";
            if (eqSelection.size() > 0) {
                objType = eqSelection.data()[0].nodeName;
            }
            // use the correct height for the element
            switch (objType) {
                case "cim:Breaker":
                case "cim:Disconnector":
                case "cim:LoadBreakSwitch":
                    term1_cy = ((SWITCH_HEIGHT/2) + (TERMINAL_RADIUS + TERMINAL_OFFSET)) * (-1);
                    term2_cy = (SWITCH_HEIGHT/2) + (TERMINAL_RADIUS + TERMINAL_OFFSET);
                    break;
                case "cim:EnergySource":
                case "cim:SynchronousMachine":
                case "cim:AsynchronousMachine":
                    term1_cy = ((GEN_HEIGHT/2) + (TERMINAL_RADIUS + TERMINAL_OFFSET)) * (-1);
                    break;
                case "cim:EnergyConsumer":
                case "cim:ConformLoad":
                case "cim:NonConformLoad":
                case "cim:EquivalentInjection":
                    term1_cy = ((LOAD_HEIGHT/2) + (TERMINAL_RADIUS + TERMINAL_OFFSET)) * (-1);
                    break;
                case "cim:PowerTransformer":
                    term1_cy = ((TRAFO_HEIGHT/2) + (TERMINAL_RADIUS + TERMINAL_OFFSET)) * (-1);
                    term2_cy = ((TRAFO_HEIGHT/2) + (TERMINAL_RADIUS + TERMINAL_OFFSET));
                    break;
                case "cim:LinearShuntCompensator":
                case "cim:NonlinearShuntCompensator":
                    term1_cy = ((COMP_HEIGHT/2) + (TERMINAL_RADIUS + TERMINAL_OFFSET)) * (-1);
                    break;
                default:
                    term2_cy = 30;
            }
            let allEdges = [];
            let updateTermSelection = eqSelection
                .selectAll("g.Terminal")
                .data(function(d) {
                    return self.props.model.getTerminals([d]);
                });
            let termSelection = updateTermSelection
                .enter()
                .append("g")
                .each(function(d, i) {
                    let cn = self.props.model.getTargets(
                        [d],
                        TERM_NODE)[0];
                    let lineData = d3.select(this.parentNode).datum().lineData;
                    let start = lineData[0];
                    let end = lineData[lineData.length-1];
                    let eqX = d3.select(this.parentNode).datum().x;
                    let eqY = d3.select(this.parentNode).datum().y;
                    if (lineData.length === 1) {
                        start = {x:0, y:term1_cy};
                        end = {x:0, y:term2_cy};
                    }

                    let eqRot = d3.select(this.parentNode).datum().rotation;
                    let terminals = self.props.model.getTerminals(d3.select(this.parentNode).data());
                    // decide where to put terminals. TODO: should handle
                    // an arbitrary number of terminals, not only two.
                    if (typeof(cn) !== "undefined" && terminals.length === 2) {
                        let dist1 = 0;
                        let dist2 = 0;
                        // handle rotation
                        if (eqRot > 0) {
                            let startRot = rotate(start, eqRot);
                            let endRot = rotate(end, eqRot);
                            dist1 = Math.pow((eqX+startRot.x-cn.x), 2)+Math.pow((eqY+startRot.y-cn.y), 2);
                            dist2 = Math.pow((eqX+endRot.x-cn.x), 2)+Math.pow((eqY+endRot.y-cn.y), 2);
                        } else {
                            dist1 = Math.pow((eqX+start.x-cn.x), 2)+Math.pow((eqY+start.y-cn.y), 2);
                            dist2 = Math.pow((eqX+end.x-cn.x), 2)+Math.pow((eqY+end.y-cn.y), 2);
                        }
                        
                        if (dist2 < dist1) {
                            d.x = eqX + end.x;
                            d.y = eqY + end.y;
                        } else {
                            d.x = eqX + start.x;
                            d.y = eqY + start.y;
                        }
                        // be sure we don't put two terminals on the same side of the equipment
                        checkTerminals(terminals, d, cn, eqX, eqY, start, end);
                    } else {
                        if (lineData.length === 1) {
                            d.x = eqX;
                            // here we have a special case for three-winding transformers
                            if (terminals.length === 3) {
                                if (i === 0) {
                                    d.y = eqY + term1_cy;
                                }
                                if (i === 1) {
                                    d.x = d.x - (TRAFO_HEIGHT/2) + (TRAFO_RADIUS);
                                    d.y = eqY + term2_cy;
                                }
                                if (i === 2) {
                                    d.x = d.x + (TRAFO_HEIGHT/2) - (TRAFO_RADIUS);
                                    d.y = eqY + term2_cy;
                                }
                                
                            } else {
                                d.y = eqY + term1_cy*(1-i) + term2_cy*i;
                            }
                        } else {
                            d.x = eqX + start.x*(1-i)+end.x*i;
                            d.y = eqY + start.y*(1-i)+end.y*i;
                        }
                    }
                    d.rotation = d3.select(this.parentNode).datum().rotation;
                    if (typeof(cn) !== "undefined" && typeof(cn.lineData) !== "undefined") {
                        let newEdge = {source: cn, target: d};
                        allEdges.push(newEdge);
                    }
                    // Now that terminal are allocated, we can handle power transformer ends
                    if (objType === "cim:PowerTransformer") {
                        self.handlePowerTransformerEnds(this);
                    }
                })
                .attr("id", function(d) {
                    return "cimdiagram-" + self.props.model.ID(d);
                })
                .attr("class", function(d) {
                    return d.localName;
                });
            self.createEdges(allEdges);
            termSelection.append("circle")
                        .attr("r", TERMINAL_RADIUS)
                        .style("fill","black")
                        .attr("cx", function(d, i) {          
                            return d3.select(this.parentNode).datum().x - d3.select(this.parentNode.parentNode).datum().x; 
                        })
                        .attr("cy", function(d, i) {
                            return d3.select(this.parentNode).datum().y - d3.select(this.parentNode.parentNode).datum().y;
                        });
            updateTermSelection
                .each(function(d, i) {
                    let eqX = d3.select(this.parentNode).datum().x;
                    let eqY = d3.select(this.parentNode).datum().y;
                    let offsetx = parseInt(d3.select(this.firstChild).attr("cx"));
                    let offsety = parseInt(d3.select(this.firstChild).attr("cy"));
                    if (offsetx === 0 && offsety === 0) {
                        d.x = eqX;
                        d.y = eqY;
                    } else {
                        let lineData = d3.select(this.parentNode).datum().lineData;
                        let end = lineData[lineData.length-1];
                        d.x = eqX + end.x;
                        d.y = eqY + end.y;
                    }
                });
            updateTermSelection.selectAll("circle")
                                .attr("cx", function(d, i) {            
                                    return d3.select(this.parentNode).datum().x - d3.select(this.parentNode.parentNode).datum().x; 
                                })
                                .attr("cy", function(d, i) {
                                    return d3.select(this.parentNode).datum().y - d3.select(this.parentNode.parentNode).datum().y;
                                });
            
            function checkTerminals(terminals, d, cn, eqX, eqY, start, end) {
                let otherTerm = terminals.filter(term => term !== d)[0];
                // we need to check if the other terminal must be moved
                let otherCn = self.props.model.getTargets(
                    [otherTerm],
                    TERM_NODE)[0];
                let termToChange = otherTerm;
                let cnToChange = otherCn;
                if(typeof(otherCn) !== "undefined") {
                    let equipments = self.props.model.getEquipments(otherCn);
                    if (equipments.length > 1) {
                        termToChange = d;
                        cnToChange = cn;
                    }
                } 
                
                if (otherTerm.x === d.x && otherTerm.y === d.y) {
                    if (d.x === eqX + end.x && d.y === eqY + end.y) {
                        termToChange.x = eqX + start.x;
                        termToChange.y = eqY + start.y;
                    } else {
                        termToChange.x = eqX + end.x;
                        termToChange.y = eqY + end.y;                      
                    }
                }
            }

            // highlight the terminals on mouseover, since they are quite small
            termSelection.each(function() {
                let term = d3.select(this).select("circle");
                d3.select(this).append("circle")
                .attr("cx", term.attr("cx"))
                .attr("cy", term.attr("cy"))
                .attr("r", HIGHLIGHT_RADIUS)
                .attr("stroke-width", 0)
                .attr("fill", "steelblue")
                .attr("fill-opacity", "0.0")
                .attr("class", "big-circle").on("mouseout", function(event, d) {
                    d3.select(this).attr("fill-opacity", "0.0");
                });
            });
            termSelection.on("mouseover", function(event, d) {
                if (d3.select(this).select("circle.selection-circle").size() === 0) {
                    d3.select(this).select("circle.big-circle").attr("fill-opacity", "0.7");
                }
            });
            
            return termSelection;
        },
   
        // Draw all nodes (connectivity or topological)
        drawNodes(allNodes) {
            let line = d3.line()
                        .x(function(d) { return d.x; })
                        .y(function(d) { return d.y; }); 
            
            for (let cn of allNodes) {
                calcLineData(self.props.model, cn);
            }
            
            if (d3.select("svg").select("g." + NODE_CLASS + "s").empty()) {
                d3.select("svg").select("g#diagram-main").append("g")
                .attr("class", NODE_CLASS + "s");
            }
            
            let cnUpdate = d3.select("svg")
                            .select("g." + NODE_CLASS + "s")
                            .selectAll("g." + NODE_CLASS)
                            .data(allNodes, function (d) {
                                return self.props.model.ID(d);
                            });

            let cnEnter = cnUpdate.enter()
                                .append("g")
                                .attr("class", NODE_CLASS)
                                .attr("id", function(d) {
                                    return "cimdiagram-" + self.props.model.ID(d);
                                });
            
            cnUpdate.select("path").attr("d", function(d) {
                let lineData = d3.select(this.parentNode).data()[0].lineData
                return line(lineData);
            }).attr("stroke", function(d) {
                return self.voltageColor(self.props.model.getBusbar(d), "black");
            });
            
            cnEnter.append("path")
                    .attr("d", function(d) {
                        let lineData = d3.select(this.parentNode).data()[0].lineData
                        return line(lineData);
                    })
                    .attr("stroke", function(d) {
                        return self.voltageColor(self.props.model.getBusbar(d), "black");
                    })
                    .attr("stroke-width", NODE_WIDTH)
                    .attr("fill", "none");
            
            // for busbars, show the name
            cnEnter
                .filter(function(d) {
                    let busbarSection = self.props.model.getBusbar(d);
                    return (busbarSection !== null);
                })
                .append("text")
                .attr("class", "cim-object-text")
                .attr("font-size", LABEL_SIZE);
            updateText(cnEnter.select("text"));
            updateText(cnUpdate.select("text"));
            
            function updateText(selection) {
                selection.attr("x", function(d) {
                    let path = d3.select(this.parentNode).select("path").node();
                    return path.getPointAtLength(path.getTotalLength()/2).x + 2;
                }).attr("y", function(d) {
                    let path = d3.select(this.parentNode).select("path").node();
                    return path.getPointAtLength(path.getTotalLength()/2).y - 2;
                }).text(function(d) {
                    // let's try to get a busbar section
                    let busbarSection = self.props.model.getBusbar(d);
                    if (busbarSection !== null) {    
                        let name = self.props.model.getAttribute(busbarSection, "cim:IdentifiedObject.name");
                        if (typeof(name) !== "undefined") {
                            return name.innerHTML;
                        }
                    }
                    return "";
                })  
            };

            return cnEnter;
        },

        moveTo(uuid) {
            let hoverD = self.props.model.getObject(uuid);
            if (typeof(hoverD) === "undefined") {
                return;
            }
            // handle busbars
            if (hoverD.nodeName === "cim:BusbarSection") {
                hoverD = self.props.model.getNode(hoverD);
            }

            // handle substations and lines
            if (hoverD.nodeName === "cim:Substation"
            || hoverD.nodeName === "cim:Line") {
                let equipments = self.props.model.getTargets(
                    [hoverD],
                    "EquipmentContainer.Equipments");
                for (let equipment of equipments) {
                    // handle busbars
                    if (equipment.nodeName === "cim:BusbarSection") {
                        let cn = self.props.model.getNode(equipment);
                        if (cn !== null) {
                            equipment = cn;
                        }
                    }
                    if (typeof(equipment.x) !== "undefined" && typeof(equipment.y) !== "undefined") {
                        hoverD.x = equipment.x;
                        hoverD.y = equipment.y;
                        break;
                    }
                }
            }
            // handle measurements
            if (hoverD.nodeName === "cim:Analog"
            || hoverD.nodeName === "cim:Discrete") {
                hoverD = self.props.model.getTargets(
                    [hoverD],
                    "Measurement.PowerSystemResource")[0];
                if (typeof(hoverD) !== "undefined") {
                    // handle busbars
                    if (hoverD.nodeName === "cim:BusbarSection") {
                        hoverD = self.props.model.getNode(hoverD);
                    }
                }
            }
            // handle power transformer ends
            if (hoverD.nodeName === "cim:PowerTransformerEnd") {
                hoverD = self.props.model.getTargets(
                    [hoverD],
                    "PowerTransformerEnd.PowerTransformer")[0];
            }
            
            if (typeof(hoverD.x) === "undefined" || typeof(hoverD.y) === "undefined") {
                return;
            }
            // hide popover before moving
            $('[data-toggle="popover"]').popover("hide");
            // do the transform
            let svgWidth = parseInt(d3.select("svg").style("width"));
            let svgHeight = parseInt(d3.select("svg").style("height"));
            let newZoom = 1;
            let newx = -hoverD.x*newZoom + (svgWidth/2);
            let newy = -hoverD.y*newZoom + (svgHeight/2);
            // apply a transition to the moving
            let trans = d3.transition()
                        .duration(750)
                        .ease(d3.easeLinear);
            let t = d3.zoomIdentity.translate(newx, newy).scale(1);
            d3.selectAll("svg").select("g#diagram-main").transition(trans).attr("transform", t);
            d3.zoom().transform(d3.selectAll("svg"), t);
            self.props.dispatcher.trigger("transform");
        },

        /** Update the diagram based on x and y values of data */
        forceTick(selection) {
            if (arguments.length === 0 || selection.alpha !== undefined) {
                // update everything
                selection = d3.select("svg").selectAll("svg > g#diagram-main > g:not(.edges) > g");
            }
                
            let transform = d3.zoomTransform(d3.select("svg").node());
            let xoffset = transform.x; 
            let yoffset = transform.y; 
            let svgZoom = transform.k; 
            updateElements(selection);

            if (arguments.length === 1) {
                let terminals = self.props.model.getTerminals(selection.data());
                let links = d3.select("svg").selectAll("svg > g#diagram-main > g.edges > g").filter(function(d) {
                    return selection.data().indexOf(d.source) > -1 || terminals.indexOf(d.target) > -1;
                });
                self.updateEdges(xoffset, yoffset, svgZoom, links);
            } else {
                self.updateEdges(xoffset, yoffset, svgZoom);
            }
            
            function updateElements(selection) {
                selection.attr("transform", function (d) {
                    return "translate("+d.x+","+d.y+") rotate("+d.rotation+")";
                }).selectAll("g.Terminal")
                        .each(function(d, i) {
                            d.x = d3.select(this.parentNode).datum().x + parseInt(d3.select(this.firstChild).attr("cx"));
                            d.y = d3.select(this.parentNode).datum().y + parseInt(d3.select(this.firstChild).attr("cy"));
                        });
                // if rotation is a multiple of 180, undo it (for readability)
                selection.selectAll("text.cim-object-text")
                        .attr("transform", function (d) {
                            let textRotation = 0;
                            let rotationOrigin = {x:0, y:0};
                            if ((d.rotation%360) === 180) {
                                textRotation = d.rotation * (-1);
                            }
                            switch (d.nodeName) {
                                case "cim:Breaker":
                                case "cim:Disconnector":
                                case "cim:LoadBreakSwitch":
                                case "cim:Junction":
                                case "cim:PowerTransformer":
                                    rotationOrigin = {x:0, y:0};
                                    break;
                                default:
                                    rotationOrigin = {
                                        x: d3.select(this).attr("x"),
                                        y: d3.select(this).attr("y")
                                    };
                                    break;
                            }
                            return "rotate("+textRotation+","+rotationOrigin.x+","+rotationOrigin.y+")";
                        });
                selection.selectAll("rect.selection-rect")
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("width", 0)
                        .attr("height", 0);
                selection.selectAll("rect.selection-rect")
                        .attr("x", function(d) {return this.parentNode.getBBox().x})
                        .attr("y", function(d) {return this.parentNode.getBBox().y})
                        .attr("width", function(d) {return this.parentNode.getBBox().width;})
                        .attr("height", function(d) {return this.parentNode.getBBox().height;});
                selection.selectAll("g.resize").selectAll("rect")
                    .attr("x", function(d) {
                        let p = d[0].lineData.filter(el => el.seq === d[1])[0];
                        return p.x - 2;
                    })
                    .attr("y", function(d) {
                        let p = d[0].lineData.filter(el => el.seq === d[1])[0];
                        return p.y - 2;
                    });
            };
        },

        /** Update the given links. If links is absent, update all links */     
        updateEdges(xoffset, yoffset, svgZoom, links) {
            let line = d3.line()
                        .x(function(d) { return d.x; })
                        .y(function(d) { return d.y; })
                        .curve(d3.curveStepBefore); 
            if (arguments.length === 3) {
                links = d3.select("svg").selectAll("svg > g#diagram-main > g.edges > g"); 
            } 

            links.select("path")
                .attr("d", function(d) {
                    let cnXY = {x: d.source.x, y: d.source.y};
                    let terminalXY = {x: d.target.x, y: d.target.y};
                    if (d.target.rotation !== 0) {
                        terminalXY = rotateTerm(self.props.model, d.target);
                    }     

                    // if the node is not a single point (e.g. it is a busbar)
                    // then we calculate the optimal position of the connection
                    // towards the terminal.
                    if (d.source.lineData.length > 1) {
                        d.p = closestPoint(d.source, terminalXY);
                    } else {
                        d.p = [0, 0];
                    }
                        
                    cnXY.x = cnXY.x + d.p[0];
                    cnXY.y = cnXY.y + d.p[1];
                    let lineData = [cnXY, terminalXY];
                    return line(lineData);
                }).attr("stroke-dasharray", function(d) {
                    let connected = self.props.model.getAttribute(d.target, "cim:ACDCTerminal.connected");
                    if (typeof(connected) !== "undefined") {
                        if (connected.textContent === "false") {
                            return "5, 5";
                        }
                    }
                    return null;
                });
        },
     
        // draw the diagram grid
        drawGrid(zoom) {
            let width = parseInt(d3.select("svg").style("width"))/zoom;
            let height = parseInt(d3.select("svg").style("height"))/zoom;
            let gridG = d3.select("svg").select("g#diagram-grid");
            gridG.selectAll("*").remove();
            const spacing = 25;
            for (let j=spacing; j <= height-spacing; j=j+spacing) {
                gridG.append("svg:line")
                    .attr("x1", 0)
                    .attr("y1", j)
                    .attr("x2", width)
                    .attr("y2", j)
                    .attr("stroke-dasharray", "1, 5")
                    .style("stroke", "rgb(6,120,155)")
                    .style("stroke-width", 1);
            };
            for (let j=spacing; j <= width-spacing; j=j+spacing) {
                gridG.append("svg:line")
                    .attr("x1", j)
                    .attr("y1", 0)
                    .attr("x2", j)
                    .attr("y2", height)
                    .attr("stroke-dasharray", "1, 5")
                    .style("stroke", "rgb(6,120,155)")
                    .style("stroke-width", 1);
            };
            gridG.attr("transform", "scale(" + zoom + ")");
        },
     
        // assign a color corresponding to the base voltage of an object. 
        voltageColor(obj, defaultCol) {
            let color = defaultCol;
            if (obj !== null && typeof(obj) !== "undefined") {
                const isTrafo = self.props.model.schema.isA("TransformerEnd", obj);
                let link = "ConductingEquipment.BaseVoltage";
                if (isTrafo === true) {
                    link = "TransformerEnd.BaseVoltage"; 
                }
                const baseVobj =  self.props.model.getTargets([obj], link)[0];
                const baseV = self.props.model.getAttribute(baseVobj, "cim:BaseVoltage.nominalVoltage");
                if (typeof(baseV) !== "undefined") {
                    if (baseV.textContent !== "") {
                        const value = baseV.textContent;
                        const voltage = parseFloat(value);
                        color = colors(voltage);
                    }
                }
            }
            return color;
        },

        drawLegend() {
            // Draw the legend
            let bvObjs = self.props.model.getObjects(["cim:BaseVoltage"])["cim:BaseVoltage"];
            d3.select("#legend-rect").attr("height", 60 + (20*bvObjs.length));
            bvObjs.sort(function(a, b) {
                const baseVa = self.props.model.getAttribute(a, "cim:BaseVoltage.nominalVoltage");
                const baseVb = self.props.model.getAttribute(b, "cim:BaseVoltage.nominalVoltage");
                if (typeof(baseVa) !== "undefined" && typeof(baseVb) !== "undefined") {
                    const valuea = baseVa.textContent;
                    const voltagea = parseFloat(valuea);
                    const valueb = baseVb.textContent;
                    const voltageb = parseFloat(valueb);
                    return voltagea < voltageb;
                }
                return 0;
            });
            // clean up
            d3.select("#diagram-legend")
            .selectAll("g.voltage")
            .remove();
            const voltages =
                d3.select("#diagram-legend")
                .selectAll("g.voltage")
                .data(bvObjs)
                .enter()
                .append("g")
                .attr("class", "voltage");
            voltages
                .append("rect")
                .attr("x", 10)
                .attr("y", function(d, i) {
                    return 50 + (20 * i);
                })
                .attr("width", 40)
                .attr("height", 10)
                .attr("fill", function(d) {
                    const baseV = self.props.model.getAttribute(d, "cim:BaseVoltage.nominalVoltage");
                    if (typeof(baseV) !== "undefined") {
                        const value = baseV.textContent;
                        const voltage = parseFloat(value);
                        return colors(voltage);
                    }
                    return "black";
                })
                .attr("stroke", "black");
            voltages
                .append("text")
                .attr("x", 60)
                .attr("y", function(d, i) {
                    return 55 + (20 * i);
                })
                .attr("dominant-baseline", "middle")
                .text(function(d) {
                    const baseV = self.props.model.getAttribute(d, "cim:BaseVoltage.nominalVoltage");
                    if (typeof(baseV) !== "undefined") {
                        if (baseV.textContent !== "") {
                            let val =  parseFloat(baseV.textContent);
                            val = +val.toFixed(1);
                            return val + " kV";
                        } else {
                            return "n.a."
                        }
                    }
                    return "undefined";
                });
        },

        updateColoring(source, linkName, target) {
            switch (linkName) {
                case "cim:ConductingEquipment.BaseVoltage":
                case "cim:BaseVoltage.ConductingEquipment": {
                    let psr = source;
                    if (linkName === "cim:BaseVoltage.ConductingEquipment") {
                        psr = target;
                    }
                    if (typeof(psr) !== "undefined") {
                        // handle aclines
                        if (psr.nodeName === "cim:ACLineSegment") {
                            self.drawACLines([psr]);
                        }
                        // handle busbars
                        if (psr.nodeName === "cim:BusbarSection") {
                            psr = self.props.model.getNode(psr);
                            self.drawNodes([psr]);
                        }
                    }
                    break;
                }
                case "cim:BaseVoltage.TransformerEnds":
                case "cim:TransformerEnd.BaseVoltage": {
                    let trafoEnd = source;
                    if (linkName === "cim:BaseVoltage.TransformerEnds") {
                        trafoEnd = target;
                    }
                    if (typeof(trafoEnd) !== "undefined") {
                        const termNode = self.getTermNode(trafoEnd);
                        if (termNode !== null) {
                            self.handlePowerTransformerEnds(termNode);
                        }
                    }
                    break;
                }
            }
        },

        // Get the node of the terminal associated to a tranformer end.
        // This is useful in a couple of cases in the code so it has a
        // dedicated function.
        // If the node is not found the function returns null.
        getTermNode(trafoEnd) {
            let result = null;
            const terms = self.props.model.getTargets([trafoEnd], "TransformerEnd.Terminal");
            const termUUID = self.props.model.ID(terms[0]);
            let termSelection = d3.select("g#cimdiagram-" + termUUID);
            if (termSelection.size() === 1) {
                result = termSelection.node();
            }
            return result;
        }
    }     
    </script>

</cimDiagram>

